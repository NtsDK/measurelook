/*Copyright 2017 Timofey Rechkalov <ntsdk@yandex.ru>

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
    limitations under the License. */

'use strict';

/* eslint-disable prefer-rest-params */

((exports) => {
    function ValidationError(messageId, parameters) {
        Error.call(this, arguments);
        this.name = 'ValidationError';

        this.messageId = messageId;
        this.parameters = parameters;

        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, ValidationError);
        } else {
            this.stack = (new Error()).stack;
        }
    }

    ValidationError.prototype = Object.create(Error.prototype);

    exports.ValidationError = ValidationError;

    function InternalError(messageId, parameters) {
        Error.call(this, arguments);
        this.name = 'InternalError';

        this.messageId = messageId;
        this.parameters = parameters;

        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, InternalError);
        } else {
            this.stack = (new Error()).stack;
        }
    }

    InternalError.prototype = Object.create(Error.prototype);

    exports.InternalError = InternalError;
})(typeof exports === 'undefined' ? this.Errors = {} : exports);

/*!
    EventEmitter v5.1.0 - git.io/ee
    Unlicense - http://unlicense.org/
    Oliver Caldwell - http://oli.me.uk/
    @preserve
*/
/* eslint-disable */
(function () {
    'use strict';

    function t() {} function i(t, n) { for (let e = t.length; e--;) if (t[e].listener === n) return e; return -1; } function n(e) { return function () { return this[e].apply(this, arguments); }; } let e = t.prototype, r = this, s = r.EventEmitter; e.getListeners = function (n) { let r, e, t = this._getEvents(); if (n instanceof RegExp) { r = {}; for (e in t)t.hasOwnProperty(e) && n.test(e) && (r[e] = t[e]); } else r = t[n] || (t[n] = []); return r; }, e.flattenListeners = function (t) { let e, n = []; for (e = 0; e < t.length; e += 1)n.push(t[e].listener); return n; }, e.getListenersAsObject = function (n) { let e, t = this.getListeners(n); return t instanceof Array && (e = {}, e[n] = t), e || t; }, e.addListener = function (r, e) { let t, n = this.getListenersAsObject(r), s = typeof e === 'object'; for (t in n)n.hasOwnProperty(t) && i(n[t], e) === -1 && n[t].push(s ? e : { listener: e, once: !1 }); return this; }, e.on = n('addListener'), e.addOnceListener = function (e, t) { return this.addListener(e, { listener: t, once: !0 }); }, e.once = n('addOnceListener'), e.defineEvent = function (e) { return this.getListeners(e), this; }, e.defineEvents = function (t) { for (let e = 0; e < t.length; e += 1) this.defineEvent(t[e]); return this; }, e.removeListener = function (r, s) { let n, e, t = this.getListenersAsObject(r); for (e in t)t.hasOwnProperty(e) && (n = i(t[e], s), n !== -1 && t[e].splice(n, 1)); return this; }, e.off = n('removeListener'), e.addListeners = function (e, t) { return this.manipulateListeners(!1, e, t); }, e.removeListeners = function (e, t) { return this.manipulateListeners(!0, e, t); }, e.manipulateListeners = function (r, t, i) { let e, n, s = r ? this.removeListener : this.addListener, o = r ? this.removeListeners : this.addListeners; if (typeof t !== 'object' || t instanceof RegExp) for (e = i.length; e--;)s.call(this, t, i[e]); else for (e in t)t.hasOwnProperty(e) && (n = t[e]) && (typeof n === 'function' ? s.call(this, e, n) : o.call(this, e, n)); return this; }, e.removeEvent = function (e) { let t, r = typeof e, n = this._getEvents(); if (r === 'string') delete n[e]; else if (e instanceof RegExp) for (t in n)n.hasOwnProperty(t) && e.test(t) && delete n[t]; else delete this._events; return this; }, e.removeAllListeners = n('removeEvent'), e.emitEvent = function (n, u) { let r, e, t, i, o, s = this.getListenersAsObject(n); for (i in s) if (s.hasOwnProperty(i)) for (r = s[i].slice(0), t = 0; t < r.length; t++)e = r[t], e.once === !0 && this.removeListener(n, e.listener), o = e.listener.apply(this, u || []), o === this._getOnceReturnValue() && this.removeListener(n, e.listener); return this; }, e.trigger = n('emitEvent'), e.emit = function (e) { const t = Array.prototype.slice.call(arguments, 1); return this.emitEvent(e, t); }, e.setOnceReturnValue = function (e) { return this._onceReturnValue = e, this; }, e._getOnceReturnValue = function () { return this.hasOwnProperty('_onceReturnValue') ? this._onceReturnValue : !0; }, e._getEvents = function () { return this._events || (this._events = {}); }, t.noConflict = function () { return r.EventEmitter = s, t; }, typeof define === 'function' && define.amd ? define(() => t) : typeof module === 'object' && module.exports ? module.exports = t : r.EventEmitter = t;
}).call(this);

/*Copyright 2017 Timofey Rechkalov <ntsdk@yandex.ru>

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
    limitations under the License. */

'use strict';

((callback) => {
    function CommonUtils(exports, R) {
        exports.startsWith = (str1, str2) => str1.substring(0, str2.length) === str2;

        exports.removeFromArrayByIndex = (array, from, to) => {
            const rest = array.slice((to || from) + 1 || array.length);
            array.length = from < 0 ? array.length + from : from;
            return array.push(...rest);
        };

        exports.charOrdAFactoryBase = R.curry((sortDir, prepare) => function cmp(a, b) {
            a = prepare(a);
            b = prepare(b);
            if (R.isNil(a) && R.isNil(b)) return 0;
            if (R.isNil(a)) return 1;
            if (R.isNil(b)) return -1;
            if (a > b) { return sortDir === 'asc' ? 1 : -1; }
            if (a < b) { return sortDir === 'asc' ? -1 : 1; }
            return 0;
        });

        exports.charOrdAFactory = exports.charOrdAFactoryBase('asc');

        exports.charOrdA = exports.charOrdAFactory(a => a.toLowerCase());

        exports.eventsByTime = exports.charOrdAFactory(a => new Date(a.time));

        exports.strFormat = (str, vals) => str.replace(/\{\{|\}\}|\{(\d+)\}/g, (m, n) => {
            if (m === '{{') { return '{'; }
            if (m === '}}') { return '}'; }
            return vals[n];
        });

        exports.consoleLog = (str) => {
            console.log(str);
        };

        exports.clone = R.clone;

        //        exports.clone = (o) => {
        //            if (!o || typeof o !== 'object') {
        //                return o;
        //            }
        //            const c = typeof o.pop === 'function' ? [] : {};
        //            let p, v;
        //            for (p in o) {
        //                if (o.hasOwnProperty(p)) {
        //                    v = o[p];
        //                    if (v && typeof v === 'object') {
        //                        c[p] = exports.clone(v);
        //                    } else {
        //                        c[p] = v;
        //                    }
        //                }
        //            }
        //            return c;
        //        };

        const pregQuote = (str, delimiter) =>
            // http://kevin.vanzonneveld.net
            // + original by: booeyOH
            // + improved by: Ates Goral (http://magnetiq.com)
            // + improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
            // + bugfixed by: Onno Marsman
            // + improved by: Brett Zamir (http://brett-zamir.me)
            // * example 1: pregQuote("$40");
            // * returns 1: '\$40'
            // * example 2: pregQuote("*RRRING* Hello?");
            // * returns 2: '\*RRRING\* Hello\?'
            // * example 3: pregQuote("\\.+*?[^]$(){}=!<>|:");
            // * returns 3: '\\\.\+\*\?\[\^\]\$\(\)\{\}\=\!\<\>\|\:'
            (`${str}`).replace(new RegExp(`[.\\\\+*?\\[\\^\\]$(){}=!<>|:\\${
                delimiter || ''}-]`, 'g'), '\\$&');

        exports.globStringToRegex = str => new RegExp(pregQuote(str).replace(/\\\*/g, '.*').replace(/\\\?/g, '.'), 'g');

        // taken from MDN https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions
        exports.escapeRegExp = string =>
            string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); // $& means the whole matched string

        exports.arr2map = (array, key) => array.reduce((a, b) => {
            a[b[key]] = b;
            return a;
        }, {});

        exports.colorPattern = /^#[0-9A-Fa-f]{6}$/;

        exports.isColor = str => exports.colorPattern.test(str);
    }

    callback(CommonUtils);
})(api => ((typeof exports === 'undefined') ? api((this.CommonUtils = {}), R) : (module.exports = api)));

/*Copyright 2017 Timofey Rechkalov <ntsdk@yandex.ru>

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
    limitations under the License. */

'use strict';

((callback2) => {
    function Precondition(exports, R, Errors) {
        exports.makeValidationError = (err) => {
            err.splice(0, 0, null);
            return new (Function.prototype.bind.apply(Errors.ValidationError, err))();
        };

        // precondition API
        exports.precondition = R.curry((check, reject, resolve) => {
            const err = check();
            if (err === null) {
                resolve();
            } else {
                reject(exports.makeValidationError(err));
            }
        });

        exports.chainCheck = R.curry(arr => () => arr.reduce((err, item) => {
            if (err) return err;
            return item();
        }, null));

        exports.eitherCheck = R.curry((func1, func2) => () => {
            const res1 = func1();
            if (res1 === null) {
                return null;
            }
            const res2 = func2();
            if (res2 === null) {
                return null;
            }
            return res1;
        });

        // primitive precondition checks
        const arrContainsElsCheck = R.curry((msg, els, valueList) => () => {
            const diff = R.difference(els, valueList);
            return diff.length === 0 ? null : [msg, [JSON.stringify(diff)]];
        });

        exports.elementsFromEnum = arrContainsElsCheck('errors-unsupported-types-in-list');
        exports.entitiesExist = arrContainsElsCheck('errors-entities-are-not-exist');

        const arrContainsElCheck = R.curry((msg, el, valueList) =>
            () => (R.contains(el, valueList) ? null : [msg, [el]]));

        exports.elementFromEnum = arrContainsElCheck('errors-unsupported-type-in-list');
        exports.entityExists = arrContainsElCheck('errors-entity-is-not-exist');

        exports.entityIsNotUsed = R.curry((el, valueList) =>
            () => (!R.contains(el, valueList) ? null : ['errors-entity-is-used', [el]]));

        exports.isString = R.curry(el =>
            () => (R.is(String, el) ? null : ['errors-argument-is-not-a-string', [el]]));

        exports.isEmptyString = R.curry(el =>
            () => (R.equals('', el) ? null : ['errors-argument-is-not-empty-string', [el]]));

        exports.isNotEmptyString = R.curry(el =>
            () => (!R.equals('', el) ? null : ['errors-argument-is-empty-string', [el]]));

        exports.nameIsNotEmpty = R.curry(el =>
            () => (!R.equals('', el) ? null : ['errors-name-is-empty-string', [el]]));

        exports.isArray = R.curry(el =>
            () => (R.is(Array, el) ? null : ['errors-argument-is-not-an-array', [el]]));

        exports.isObject = R.curry(el =>
            () => (R.is(Object, el) ? null : ['errors-argument-is-not-an-object', [el]]));

        exports.isBoolean = R.curry(el =>
            () => (R.is(Boolean, el) ? null : ['errors-argument-is-not-a-boolean', [el]]));

        exports.isNumber = R.curry(el =>
            () => (R.is(Number, el) ? null : ['errors-argument-is-not-a-number', [el]]));

        exports.isNil = R.curry(el =>
            () => (R.isNil(el) ? null : ['errors-argument-is-not-nil', [el]]));

        exports.nil = R.curry(() => () => null);

        exports.notEquals = R.curry((el, el2) =>
            () => (!R.equals(el, el2) ? null : ['errors-argument-must-not-be-equal', [el]]));

        exports.equals = R.curry((el, el2) =>
            () => (R.equals(el, el2) ? null : ['errors-arguments-must-be-equal', [el, el2]]));

        exports.isInRange = R.curry((el, low, up) =>
            () => (low <= el && el <= up ? null : ['errors-argument-is-not-in-range', [el, low, up]]));

        exports.isNonNegative = R.curry(el =>
            () => (el >= 0 ? null : ['errors-argument-is-negative', [el]]));

        exports.createEntityCheck = R.curry((entityName, entityList) =>
            exports.chainCheck([exports.isString(entityName), exports.nameIsNotEmpty(entityName),
                exports.entityIsNotUsed(entityName, entityList)]));

        exports.removeEntityCheck = R.curry((entityName, entityList) =>
            exports.chainCheck([exports.isString(entityName), exports.entityExists(entityName, entityList)]));

        exports.entityExistsCheck = exports.removeEntityCheck;

        exports.renameEntityCheck = R.curry((fromName, toName, entityList) =>
            exports.chainCheck([exports.removeEntityCheck(fromName, entityList),
                exports.createEntityCheck(toName, entityList)]));

        exports.switchEntityCheck = R.curry((entity1, entity2, entityList, entityContainerList) =>
            exports.chainCheck([exports.entityExistsCheck(entity1, entityList),
                exports.entityExistsCheck(entity2, entityList),
                exports.entityExists(entity1, entityContainerList),
                exports.entityIsNotUsed(entity2, entityContainerList)]));

        exports.patternCheck = R.curry((el, regex) => () =>
            (regex.test(el) ? null : ['errors-argument-doesnt-match-pattern', [el, regex.toString()]]));

        exports.arrayCheck = R.curry((arr, check) => exports.chainCheck(arr.map(check)));

        exports.getValueCheck = (type) => {
            switch (type) {
            case 'checkbox':
                return exports.isBoolean;
            case 'number':
                return exports.isNumber;
            default:
                return exports.isString;
            }
        };
    }

    callback2(Precondition);
})(api => ((typeof exports === 'undefined') ? api((this.Precondition = {}), R, Errors) : (module.exports = api)));

/*
    Date Format 1.2.3
    (c) 2007-2009 Steven Levithan <stevenlevithan.com>
    MIT license

    Includes enhancements by Scott Trenda <scott.trenda.net>
    and Kris Kowal <cixar.com/~kris.kowal/>

    Accepts a date, a mask, or a date and a mask.
    Returns a formatted version of the given date.
    The date defaults to the current date/time.
    The mask defaults to dateFormat.masks.default.
*/

// Thanks for your work ;)
// NtsDK

/* eslint-disable */

(function (callback) {
    var dateFormat = (function () {
        let token = /d{1,4}|m{1,4}|yy(?:yy)?|([HhMsTt])\1?|[LloSZ]|"[^"]*"|'[^']*'/g,
            timezone = /\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g,
            timezoneClip = /[^-+\dA-Z]/g,
            pad = function (val, len) {
                val = String(val);
                len = len || 2;
                while (val.length < len) val = `0${val}`;
                return val;
            };

        // Regexes and supporting functions are cached through closure
        return function (date, mask, utc) {
            const dF = dateFormat;

            // You can't provide utc if you skip other args (use the "UTC:" mask prefix)
            if (arguments.length == 1 && Object.prototype.toString.call(date) == '[object String]' && !/\d/.test(date)) {
                mask = date;
                date = undefined;
            }

            // Passing date through Date applies Date.parse, if necessary
            date = date ? new Date(date) : new Date();
            if (isNaN(date)) throw SyntaxError('invalid date');

            mask = String(dF.masks[mask] || mask || dF.masks.default);

            // Allow setting the utc argument via the mask
            if (mask.slice(0, 4) == 'UTC:') {
                mask = mask.slice(4);
                utc = true;
            }

            let _ = utc ? 'getUTC' : 'get',
                d = date[`${_}Date`](),
                D = date[`${_}Day`](),
                m = date[`${_}Month`](),
                y = date[`${_}FullYear`](),
                H = date[`${_}Hours`](),
                M = date[`${_}Minutes`](),
                s = date[`${_}Seconds`](),
                L = date[`${_}Milliseconds`](),
                o = utc ? 0 : date.getTimezoneOffset(),
                flags = {
                    d,
                    dd: pad(d),
                    ddd: dF.i18n.dayNames[D],
                    dddd: dF.i18n.dayNames[D + 7],
                    m: m + 1,
                    mm: pad(m + 1),
                    mmm: dF.i18n.monthNames[m],
                    mmmm: dF.i18n.monthNames[m + 12],
                    yy: String(y).slice(2),
                    yyyy: y,
                    h: H % 12 || 12,
                    hh: pad(H % 12 || 12),
                    H,
                    HH: pad(H),
                    M,
                    MM: pad(M),
                    s,
                    ss: pad(s),
                    l: pad(L, 3),
                    L: pad(L > 99 ? Math.round(L / 10) : L),
                    t: H < 12 ? 'a' : 'p',
                    tt: H < 12 ? 'am' : 'pm',
                    T: H < 12 ? 'A' : 'P',
                    TT: H < 12 ? 'AM' : 'PM',
                    Z: utc ? 'UTC' : (String(date).match(timezone) || ['']).pop().replace(timezoneClip, ''),
                    o: (o > 0 ? '-' : '+') + pad(Math.floor(Math.abs(o) / 60) * 100 + Math.abs(o) % 60, 4),
                    S: ['th', 'st', 'nd', 'rd'][d % 10 > 3 ? 0 : (d % 100 - d % 10 != 10) * d % 10]
                };

            return mask.replace(token, $0 => ($0 in flags ? flags[$0] : $0.slice(1, $0.length - 1)));
        };
    }());

    // Some common format strings
    dateFormat.masks = {
        default: 'ddd mmm dd yyyy HH:MM:ss',
        shortDate: 'm/d/yy',
        mediumDate: 'mmm d, yyyy',
        longDate: 'mmmm d, yyyy',
        fullDate: 'dddd, mmmm d, yyyy',
        shortTime: 'h:MM TT',
        mediumTime: 'h:MM:ss TT',
        longTime: 'h:MM:ss TT Z',
        isoDate: 'yyyy-mm-dd',
        isoTime: 'HH:MM:ss',
        isoDateTime: 'yyyy-mm-dd\'T\'HH:MM:ss',
        isoUtcDateTime: 'UTC:yyyy-mm-dd\'T\'HH:MM:ss\'Z\''
    };

    // Internationalization strings
    dateFormat.i18n = {
        dayNames: [
            'Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat',
            'Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'
        ],
        monthNames: [
            'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec',
            'January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'
        ]
    };

    callback(dateFormat);
}(dateFormat => ((typeof exports === 'undefined') ? (this.dateFormat = dateFormat) : (module.exports = dateFormat))));

var defaultLang = 'ru';

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL2NvcmUvanMvY29tbW9uL2Vycm9ycy5qcyIsIi4uL2NvcmUvanMvY29tbW9uL0V2ZW50RW1pdHRlci5qcyIsIi4uL2NvcmUvanMvY29tbW9uL2NvbW1vblV0aWxzLmpzIiwiLi4vY29yZS9qcy9jb21tb24vcHJlY29uZGl0aW9uLmpzIiwiLi4vY29yZS9qcy9jb21tb24vZGF0ZUZvcm1hdC5qcyIsIi4uLy4uLy4uLy4uL3NtdGstbmltcy10cmFuc2xhdGlvbnMvbWVhc3VyZWxvb2svcnUvZGVmYXVsdExhbmcuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDNUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDbkpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUMvSEE7QUFDQSIsImZpbGUiOiJjb21tb25Db3JlLm1pbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qQ29weXJpZ2h0IDIwMTcgVGltb2ZleSBSZWNoa2Fsb3YgPG50c2RrQHlhbmRleC5ydT5cclxuXHJcbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcblxyXG5odHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gICAgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG4vKiBlc2xpbnQtZGlzYWJsZSBwcmVmZXItcmVzdC1wYXJhbXMgKi9cclxuXHJcbigoZXhwb3J0cykgPT4ge1xyXG4gICAgZnVuY3Rpb24gVmFsaWRhdGlvbkVycm9yKG1lc3NhZ2VJZCwgcGFyYW1ldGVycykge1xyXG4gICAgICAgIEVycm9yLmNhbGwodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICB0aGlzLm5hbWUgPSAnVmFsaWRhdGlvbkVycm9yJztcclxuXHJcbiAgICAgICAgdGhpcy5tZXNzYWdlSWQgPSBtZXNzYWdlSWQ7XHJcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJzID0gcGFyYW1ldGVycztcclxuXHJcbiAgICAgICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XHJcbiAgICAgICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIFZhbGlkYXRpb25FcnJvcik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5zdGFjayA9IChuZXcgRXJyb3IoKSkuc3RhY2s7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIFZhbGlkYXRpb25FcnJvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEVycm9yLnByb3RvdHlwZSk7XHJcblxyXG4gICAgZXhwb3J0cy5WYWxpZGF0aW9uRXJyb3IgPSBWYWxpZGF0aW9uRXJyb3I7XHJcblxyXG4gICAgZnVuY3Rpb24gSW50ZXJuYWxFcnJvcihtZXNzYWdlSWQsIHBhcmFtZXRlcnMpIHtcclxuICAgICAgICBFcnJvci5jYWxsKHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgdGhpcy5uYW1lID0gJ0ludGVybmFsRXJyb3InO1xyXG5cclxuICAgICAgICB0aGlzLm1lc3NhZ2VJZCA9IG1lc3NhZ2VJZDtcclxuICAgICAgICB0aGlzLnBhcmFtZXRlcnMgPSBwYXJhbWV0ZXJzO1xyXG5cclxuICAgICAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcclxuICAgICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgSW50ZXJuYWxFcnJvcik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5zdGFjayA9IChuZXcgRXJyb3IoKSkuc3RhY2s7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIEludGVybmFsRXJyb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFcnJvci5wcm90b3R5cGUpO1xyXG5cclxuICAgIGV4cG9ydHMuSW50ZXJuYWxFcnJvciA9IEludGVybmFsRXJyb3I7XHJcbn0pKHR5cGVvZiBleHBvcnRzID09PSAndW5kZWZpbmVkJyA/IHRoaXMuRXJyb3JzID0ge30gOiBleHBvcnRzKTtcclxuIiwiLyohXHJcbiAgICBFdmVudEVtaXR0ZXIgdjUuMS4wIC0gZ2l0LmlvL2VlXHJcbiAgICBVbmxpY2Vuc2UgLSBodHRwOi8vdW5saWNlbnNlLm9yZy9cclxuICAgIE9saXZlciBDYWxkd2VsbCAtIGh0dHA6Ly9vbGkubWUudWsvXHJcbiAgICBAcHJlc2VydmVcclxuKi9cclxuLyogZXNsaW50LWRpc2FibGUgKi9cclxuKGZ1bmN0aW9uICgpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgICBmdW5jdGlvbiB0KCkge30gZnVuY3Rpb24gaSh0LCBuKSB7IGZvciAobGV0IGUgPSB0Lmxlbmd0aDsgZS0tOykgaWYgKHRbZV0ubGlzdGVuZXIgPT09IG4pIHJldHVybiBlOyByZXR1cm4gLTE7IH0gZnVuY3Rpb24gbihlKSB7IHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzW2VdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH07IH0gbGV0IGUgPSB0LnByb3RvdHlwZSwgciA9IHRoaXMsIHMgPSByLkV2ZW50RW1pdHRlcjsgZS5nZXRMaXN0ZW5lcnMgPSBmdW5jdGlvbiAobikgeyBsZXQgciwgZSwgdCA9IHRoaXMuX2dldEV2ZW50cygpOyBpZiAobiBpbnN0YW5jZW9mIFJlZ0V4cCkgeyByID0ge307IGZvciAoZSBpbiB0KXQuaGFzT3duUHJvcGVydHkoZSkgJiYgbi50ZXN0KGUpICYmIChyW2VdID0gdFtlXSk7IH0gZWxzZSByID0gdFtuXSB8fCAodFtuXSA9IFtdKTsgcmV0dXJuIHI7IH0sIGUuZmxhdHRlbkxpc3RlbmVycyA9IGZ1bmN0aW9uICh0KSB7IGxldCBlLCBuID0gW107IGZvciAoZSA9IDA7IGUgPCB0Lmxlbmd0aDsgZSArPSAxKW4ucHVzaCh0W2VdLmxpc3RlbmVyKTsgcmV0dXJuIG47IH0sIGUuZ2V0TGlzdGVuZXJzQXNPYmplY3QgPSBmdW5jdGlvbiAobikgeyBsZXQgZSwgdCA9IHRoaXMuZ2V0TGlzdGVuZXJzKG4pOyByZXR1cm4gdCBpbnN0YW5jZW9mIEFycmF5ICYmIChlID0ge30sIGVbbl0gPSB0KSwgZSB8fCB0OyB9LCBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24gKHIsIGUpIHsgbGV0IHQsIG4gPSB0aGlzLmdldExpc3RlbmVyc0FzT2JqZWN0KHIpLCBzID0gdHlwZW9mIGUgPT09ICdvYmplY3QnOyBmb3IgKHQgaW4gbiluLmhhc093blByb3BlcnR5KHQpICYmIGkoblt0XSwgZSkgPT09IC0xICYmIG5bdF0ucHVzaChzID8gZSA6IHsgbGlzdGVuZXI6IGUsIG9uY2U6ICExIH0pOyByZXR1cm4gdGhpczsgfSwgZS5vbiA9IG4oJ2FkZExpc3RlbmVyJyksIGUuYWRkT25jZUxpc3RlbmVyID0gZnVuY3Rpb24gKGUsIHQpIHsgcmV0dXJuIHRoaXMuYWRkTGlzdGVuZXIoZSwgeyBsaXN0ZW5lcjogdCwgb25jZTogITAgfSk7IH0sIGUub25jZSA9IG4oJ2FkZE9uY2VMaXN0ZW5lcicpLCBlLmRlZmluZUV2ZW50ID0gZnVuY3Rpb24gKGUpIHsgcmV0dXJuIHRoaXMuZ2V0TGlzdGVuZXJzKGUpLCB0aGlzOyB9LCBlLmRlZmluZUV2ZW50cyA9IGZ1bmN0aW9uICh0KSB7IGZvciAobGV0IGUgPSAwOyBlIDwgdC5sZW5ndGg7IGUgKz0gMSkgdGhpcy5kZWZpbmVFdmVudCh0W2VdKTsgcmV0dXJuIHRoaXM7IH0sIGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiAociwgcykgeyBsZXQgbiwgZSwgdCA9IHRoaXMuZ2V0TGlzdGVuZXJzQXNPYmplY3Qocik7IGZvciAoZSBpbiB0KXQuaGFzT3duUHJvcGVydHkoZSkgJiYgKG4gPSBpKHRbZV0sIHMpLCBuICE9PSAtMSAmJiB0W2VdLnNwbGljZShuLCAxKSk7IHJldHVybiB0aGlzOyB9LCBlLm9mZiA9IG4oJ3JlbW92ZUxpc3RlbmVyJyksIGUuYWRkTGlzdGVuZXJzID0gZnVuY3Rpb24gKGUsIHQpIHsgcmV0dXJuIHRoaXMubWFuaXB1bGF0ZUxpc3RlbmVycyghMSwgZSwgdCk7IH0sIGUucmVtb3ZlTGlzdGVuZXJzID0gZnVuY3Rpb24gKGUsIHQpIHsgcmV0dXJuIHRoaXMubWFuaXB1bGF0ZUxpc3RlbmVycyghMCwgZSwgdCk7IH0sIGUubWFuaXB1bGF0ZUxpc3RlbmVycyA9IGZ1bmN0aW9uIChyLCB0LCBpKSB7IGxldCBlLCBuLCBzID0gciA/IHRoaXMucmVtb3ZlTGlzdGVuZXIgOiB0aGlzLmFkZExpc3RlbmVyLCBvID0gciA/IHRoaXMucmVtb3ZlTGlzdGVuZXJzIDogdGhpcy5hZGRMaXN0ZW5lcnM7IGlmICh0eXBlb2YgdCAhPT0gJ29iamVjdCcgfHwgdCBpbnN0YW5jZW9mIFJlZ0V4cCkgZm9yIChlID0gaS5sZW5ndGg7IGUtLTspcy5jYWxsKHRoaXMsIHQsIGlbZV0pOyBlbHNlIGZvciAoZSBpbiB0KXQuaGFzT3duUHJvcGVydHkoZSkgJiYgKG4gPSB0W2VdKSAmJiAodHlwZW9mIG4gPT09ICdmdW5jdGlvbicgPyBzLmNhbGwodGhpcywgZSwgbikgOiBvLmNhbGwodGhpcywgZSwgbikpOyByZXR1cm4gdGhpczsgfSwgZS5yZW1vdmVFdmVudCA9IGZ1bmN0aW9uIChlKSB7IGxldCB0LCByID0gdHlwZW9mIGUsIG4gPSB0aGlzLl9nZXRFdmVudHMoKTsgaWYgKHIgPT09ICdzdHJpbmcnKSBkZWxldGUgbltlXTsgZWxzZSBpZiAoZSBpbnN0YW5jZW9mIFJlZ0V4cCkgZm9yICh0IGluIG4pbi5oYXNPd25Qcm9wZXJ0eSh0KSAmJiBlLnRlc3QodCkgJiYgZGVsZXRlIG5bdF07IGVsc2UgZGVsZXRlIHRoaXMuX2V2ZW50czsgcmV0dXJuIHRoaXM7IH0sIGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gbigncmVtb3ZlRXZlbnQnKSwgZS5lbWl0RXZlbnQgPSBmdW5jdGlvbiAobiwgdSkgeyBsZXQgciwgZSwgdCwgaSwgbywgcyA9IHRoaXMuZ2V0TGlzdGVuZXJzQXNPYmplY3Qobik7IGZvciAoaSBpbiBzKSBpZiAocy5oYXNPd25Qcm9wZXJ0eShpKSkgZm9yIChyID0gc1tpXS5zbGljZSgwKSwgdCA9IDA7IHQgPCByLmxlbmd0aDsgdCsrKWUgPSByW3RdLCBlLm9uY2UgPT09ICEwICYmIHRoaXMucmVtb3ZlTGlzdGVuZXIobiwgZS5saXN0ZW5lciksIG8gPSBlLmxpc3RlbmVyLmFwcGx5KHRoaXMsIHUgfHwgW10pLCBvID09PSB0aGlzLl9nZXRPbmNlUmV0dXJuVmFsdWUoKSAmJiB0aGlzLnJlbW92ZUxpc3RlbmVyKG4sIGUubGlzdGVuZXIpOyByZXR1cm4gdGhpczsgfSwgZS50cmlnZ2VyID0gbignZW1pdEV2ZW50JyksIGUuZW1pdCA9IGZ1bmN0aW9uIChlKSB7IGNvbnN0IHQgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpOyByZXR1cm4gdGhpcy5lbWl0RXZlbnQoZSwgdCk7IH0sIGUuc2V0T25jZVJldHVyblZhbHVlID0gZnVuY3Rpb24gKGUpIHsgcmV0dXJuIHRoaXMuX29uY2VSZXR1cm5WYWx1ZSA9IGUsIHRoaXM7IH0sIGUuX2dldE9uY2VSZXR1cm5WYWx1ZSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuaGFzT3duUHJvcGVydHkoJ19vbmNlUmV0dXJuVmFsdWUnKSA/IHRoaXMuX29uY2VSZXR1cm5WYWx1ZSA6ICEwOyB9LCBlLl9nZXRFdmVudHMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9ldmVudHMgfHwgKHRoaXMuX2V2ZW50cyA9IHt9KTsgfSwgdC5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gci5FdmVudEVtaXR0ZXIgPSBzLCB0OyB9LCB0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoKCkgPT4gdCkgOiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cyA/IG1vZHVsZS5leHBvcnRzID0gdCA6IHIuRXZlbnRFbWl0dGVyID0gdDtcclxufSkuY2FsbCh0aGlzKTtcclxuIiwiLypDb3B5cmlnaHQgMjAxNyBUaW1vZmV5IFJlY2hrYWxvdiA8bnRzZGtAeWFuZGV4LnJ1PlxyXG5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuXHJcbmh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAgICBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbigoY2FsbGJhY2spID0+IHtcclxuICAgIGZ1bmN0aW9uIENvbW1vblV0aWxzKGV4cG9ydHMsIFIpIHtcclxuICAgICAgICBleHBvcnRzLnN0YXJ0c1dpdGggPSAoc3RyMSwgc3RyMikgPT4gc3RyMS5zdWJzdHJpbmcoMCwgc3RyMi5sZW5ndGgpID09PSBzdHIyO1xyXG5cclxuICAgICAgICBleHBvcnRzLnJlbW92ZUZyb21BcnJheUJ5SW5kZXggPSAoYXJyYXksIGZyb20sIHRvKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlc3QgPSBhcnJheS5zbGljZSgodG8gfHwgZnJvbSkgKyAxIHx8IGFycmF5Lmxlbmd0aCk7XHJcbiAgICAgICAgICAgIGFycmF5Lmxlbmd0aCA9IGZyb20gPCAwID8gYXJyYXkubGVuZ3RoICsgZnJvbSA6IGZyb207XHJcbiAgICAgICAgICAgIHJldHVybiBhcnJheS5wdXNoKC4uLnJlc3QpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGV4cG9ydHMuY2hhck9yZEFGYWN0b3J5QmFzZSA9IFIuY3VycnkoKHNvcnREaXIsIHByZXBhcmUpID0+IGZ1bmN0aW9uIGNtcChhLCBiKSB7XHJcbiAgICAgICAgICAgIGEgPSBwcmVwYXJlKGEpO1xyXG4gICAgICAgICAgICBiID0gcHJlcGFyZShiKTtcclxuICAgICAgICAgICAgaWYgKFIuaXNOaWwoYSkgJiYgUi5pc05pbChiKSkgcmV0dXJuIDA7XHJcbiAgICAgICAgICAgIGlmIChSLmlzTmlsKGEpKSByZXR1cm4gMTtcclxuICAgICAgICAgICAgaWYgKFIuaXNOaWwoYikpIHJldHVybiAtMTtcclxuICAgICAgICAgICAgaWYgKGEgPiBiKSB7IHJldHVybiBzb3J0RGlyID09PSAnYXNjJyA/IDEgOiAtMTsgfVxyXG4gICAgICAgICAgICBpZiAoYSA8IGIpIHsgcmV0dXJuIHNvcnREaXIgPT09ICdhc2MnID8gLTEgOiAxOyB9XHJcbiAgICAgICAgICAgIHJldHVybiAwO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBleHBvcnRzLmNoYXJPcmRBRmFjdG9yeSA9IGV4cG9ydHMuY2hhck9yZEFGYWN0b3J5QmFzZSgnYXNjJyk7XHJcblxyXG4gICAgICAgIGV4cG9ydHMuY2hhck9yZEEgPSBleHBvcnRzLmNoYXJPcmRBRmFjdG9yeShhID0+IGEudG9Mb3dlckNhc2UoKSk7XHJcblxyXG4gICAgICAgIGV4cG9ydHMuZXZlbnRzQnlUaW1lID0gZXhwb3J0cy5jaGFyT3JkQUZhY3RvcnkoYSA9PiBuZXcgRGF0ZShhLnRpbWUpKTtcclxuXHJcbiAgICAgICAgZXhwb3J0cy5zdHJGb3JtYXQgPSAoc3RyLCB2YWxzKSA9PiBzdHIucmVwbGFjZSgvXFx7XFx7fFxcfVxcfXxcXHsoXFxkKylcXH0vZywgKG0sIG4pID0+IHtcclxuICAgICAgICAgICAgaWYgKG0gPT09ICd7eycpIHsgcmV0dXJuICd7JzsgfVxyXG4gICAgICAgICAgICBpZiAobSA9PT0gJ319JykgeyByZXR1cm4gJ30nOyB9XHJcbiAgICAgICAgICAgIHJldHVybiB2YWxzW25dO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBleHBvcnRzLmNvbnNvbGVMb2cgPSAoc3RyKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHN0cik7XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgZXhwb3J0cy5jbG9uZSA9IFIuY2xvbmU7XHJcblxyXG4gICAgICAgIC8vICAgICAgICBleHBvcnRzLmNsb25lID0gKG8pID0+IHtcclxuICAgICAgICAvLyAgICAgICAgICAgIGlmICghbyB8fCB0eXBlb2YgbyAhPT0gJ29iamVjdCcpIHtcclxuICAgICAgICAvLyAgICAgICAgICAgICAgICByZXR1cm4gbztcclxuICAgICAgICAvLyAgICAgICAgICAgIH1cclxuICAgICAgICAvLyAgICAgICAgICAgIGNvbnN0IGMgPSB0eXBlb2Ygby5wb3AgPT09ICdmdW5jdGlvbicgPyBbXSA6IHt9O1xyXG4gICAgICAgIC8vICAgICAgICAgICAgbGV0IHAsIHY7XHJcbiAgICAgICAgLy8gICAgICAgICAgICBmb3IgKHAgaW4gbykge1xyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgIGlmIChvLmhhc093blByb3BlcnR5KHApKSB7XHJcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgIHYgPSBvW3BdO1xyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICBpZiAodiAmJiB0eXBlb2YgdiA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAgICAgIGNbcF0gPSBleHBvcnRzLmNsb25lKHYpO1xyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgICAgY1twXSA9IHY7XHJcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAvLyAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgLy8gICAgICAgICAgICB9XHJcbiAgICAgICAgLy8gICAgICAgICAgICByZXR1cm4gYztcclxuICAgICAgICAvLyAgICAgICAgfTtcclxuXHJcbiAgICAgICAgY29uc3QgcHJlZ1F1b3RlID0gKHN0ciwgZGVsaW1pdGVyKSA9PlxyXG4gICAgICAgICAgICAvLyBodHRwOi8va2V2aW4udmFuem9ubmV2ZWxkLm5ldFxyXG4gICAgICAgICAgICAvLyArIG9yaWdpbmFsIGJ5OiBib29leU9IXHJcbiAgICAgICAgICAgIC8vICsgaW1wcm92ZWQgYnk6IEF0ZXMgR29yYWwgKGh0dHA6Ly9tYWduZXRpcS5jb20pXHJcbiAgICAgICAgICAgIC8vICsgaW1wcm92ZWQgYnk6IEtldmluIHZhbiBab25uZXZlbGQgKGh0dHA6Ly9rZXZpbi52YW56b25uZXZlbGQubmV0KVxyXG4gICAgICAgICAgICAvLyArIGJ1Z2ZpeGVkIGJ5OiBPbm5vIE1hcnNtYW5cclxuICAgICAgICAgICAgLy8gKyBpbXByb3ZlZCBieTogQnJldHQgWmFtaXIgKGh0dHA6Ly9icmV0dC16YW1pci5tZSlcclxuICAgICAgICAgICAgLy8gKiBleGFtcGxlIDE6IHByZWdRdW90ZShcIiQ0MFwiKTtcclxuICAgICAgICAgICAgLy8gKiByZXR1cm5zIDE6ICdcXCQ0MCdcclxuICAgICAgICAgICAgLy8gKiBleGFtcGxlIDI6IHByZWdRdW90ZShcIipSUlJJTkcqIEhlbGxvP1wiKTtcclxuICAgICAgICAgICAgLy8gKiByZXR1cm5zIDI6ICdcXCpSUlJJTkdcXCogSGVsbG9cXD8nXHJcbiAgICAgICAgICAgIC8vICogZXhhbXBsZSAzOiBwcmVnUXVvdGUoXCJcXFxcLisqP1teXSQoKXt9PSE8Pnw6XCIpO1xyXG4gICAgICAgICAgICAvLyAqIHJldHVybnMgMzogJ1xcXFxcXC5cXCtcXCpcXD9cXFtcXF5cXF1cXCRcXChcXClcXHtcXH1cXD1cXCFcXDxcXD5cXHxcXDonXHJcbiAgICAgICAgICAgIChgJHtzdHJ9YCkucmVwbGFjZShuZXcgUmVnRXhwKGBbLlxcXFxcXFxcKyo/XFxcXFtcXFxcXlxcXFxdJCgpe309ITw+fDpcXFxcJHtcclxuICAgICAgICAgICAgICAgIGRlbGltaXRlciB8fCAnJ30tXWAsICdnJyksICdcXFxcJCYnKTtcclxuXHJcbiAgICAgICAgZXhwb3J0cy5nbG9iU3RyaW5nVG9SZWdleCA9IHN0ciA9PiBuZXcgUmVnRXhwKHByZWdRdW90ZShzdHIpLnJlcGxhY2UoL1xcXFxcXCovZywgJy4qJykucmVwbGFjZSgvXFxcXFxcPy9nLCAnLicpLCAnZycpO1xyXG5cclxuICAgICAgICAvLyB0YWtlbiBmcm9tIE1ETiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L0d1aWRlL1JlZ3VsYXJfRXhwcmVzc2lvbnNcclxuICAgICAgICBleHBvcnRzLmVzY2FwZVJlZ0V4cCA9IHN0cmluZyA9PlxyXG4gICAgICAgICAgICBzdHJpbmcucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csICdcXFxcJCYnKTsgLy8gJCYgbWVhbnMgdGhlIHdob2xlIG1hdGNoZWQgc3RyaW5nXHJcblxyXG4gICAgICAgIGV4cG9ydHMuYXJyMm1hcCA9IChhcnJheSwga2V5KSA9PiBhcnJheS5yZWR1Y2UoKGEsIGIpID0+IHtcclxuICAgICAgICAgICAgYVtiW2tleV1dID0gYjtcclxuICAgICAgICAgICAgcmV0dXJuIGE7XHJcbiAgICAgICAgfSwge30pO1xyXG5cclxuICAgICAgICBleHBvcnRzLmNvbG9yUGF0dGVybiA9IC9eI1swLTlBLUZhLWZdezZ9JC87XHJcblxyXG4gICAgICAgIGV4cG9ydHMuaXNDb2xvciA9IHN0ciA9PiBleHBvcnRzLmNvbG9yUGF0dGVybi50ZXN0KHN0cik7XHJcbiAgICB9XHJcblxyXG4gICAgY2FsbGJhY2soQ29tbW9uVXRpbHMpO1xyXG59KShhcGkgPT4gKCh0eXBlb2YgZXhwb3J0cyA9PT0gJ3VuZGVmaW5lZCcpID8gYXBpKCh0aGlzLkNvbW1vblV0aWxzID0ge30pLCBSKSA6IChtb2R1bGUuZXhwb3J0cyA9IGFwaSkpKTtcclxuIiwiLypDb3B5cmlnaHQgMjAxNyBUaW1vZmV5IFJlY2hrYWxvdiA8bnRzZGtAeWFuZGV4LnJ1PlxyXG5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuXHJcbmh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAgICBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbigoY2FsbGJhY2syKSA9PiB7XHJcbiAgICBmdW5jdGlvbiBQcmVjb25kaXRpb24oZXhwb3J0cywgUiwgRXJyb3JzKSB7XHJcbiAgICAgICAgZXhwb3J0cy5tYWtlVmFsaWRhdGlvbkVycm9yID0gKGVycikgPT4ge1xyXG4gICAgICAgICAgICBlcnIuc3BsaWNlKDAsIDAsIG51bGwpO1xyXG4gICAgICAgICAgICByZXR1cm4gbmV3IChGdW5jdGlvbi5wcm90b3R5cGUuYmluZC5hcHBseShFcnJvcnMuVmFsaWRhdGlvbkVycm9yLCBlcnIpKSgpO1xyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIHByZWNvbmRpdGlvbiBBUElcclxuICAgICAgICBleHBvcnRzLnByZWNvbmRpdGlvbiA9IFIuY3VycnkoKGNoZWNrLCByZWplY3QsIHJlc29sdmUpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgZXJyID0gY2hlY2soKTtcclxuICAgICAgICAgICAgaWYgKGVyciA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGV4cG9ydHMubWFrZVZhbGlkYXRpb25FcnJvcihlcnIpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBleHBvcnRzLmNoYWluQ2hlY2sgPSBSLmN1cnJ5KGFyciA9PiAoKSA9PiBhcnIucmVkdWNlKChlcnIsIGl0ZW0pID0+IHtcclxuICAgICAgICAgICAgaWYgKGVycikgcmV0dXJuIGVycjtcclxuICAgICAgICAgICAgcmV0dXJuIGl0ZW0oKTtcclxuICAgICAgICB9LCBudWxsKSk7XHJcblxyXG4gICAgICAgIGV4cG9ydHMuZWl0aGVyQ2hlY2sgPSBSLmN1cnJ5KChmdW5jMSwgZnVuYzIpID0+ICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcmVzMSA9IGZ1bmMxKCk7XHJcbiAgICAgICAgICAgIGlmIChyZXMxID09PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zdCByZXMyID0gZnVuYzIoKTtcclxuICAgICAgICAgICAgaWYgKHJlczIgPT09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiByZXMxO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICAvLyBwcmltaXRpdmUgcHJlY29uZGl0aW9uIGNoZWNrc1xyXG4gICAgICAgIGNvbnN0IGFyckNvbnRhaW5zRWxzQ2hlY2sgPSBSLmN1cnJ5KChtc2csIGVscywgdmFsdWVMaXN0KSA9PiAoKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRpZmYgPSBSLmRpZmZlcmVuY2UoZWxzLCB2YWx1ZUxpc3QpO1xyXG4gICAgICAgICAgICByZXR1cm4gZGlmZi5sZW5ndGggPT09IDAgPyBudWxsIDogW21zZywgW0pTT04uc3RyaW5naWZ5KGRpZmYpXV07XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGV4cG9ydHMuZWxlbWVudHNGcm9tRW51bSA9IGFyckNvbnRhaW5zRWxzQ2hlY2soJ2Vycm9ycy11bnN1cHBvcnRlZC10eXBlcy1pbi1saXN0Jyk7XHJcbiAgICAgICAgZXhwb3J0cy5lbnRpdGllc0V4aXN0ID0gYXJyQ29udGFpbnNFbHNDaGVjaygnZXJyb3JzLWVudGl0aWVzLWFyZS1ub3QtZXhpc3QnKTtcclxuXHJcbiAgICAgICAgY29uc3QgYXJyQ29udGFpbnNFbENoZWNrID0gUi5jdXJyeSgobXNnLCBlbCwgdmFsdWVMaXN0KSA9PlxyXG4gICAgICAgICAgICAoKSA9PiAoUi5jb250YWlucyhlbCwgdmFsdWVMaXN0KSA/IG51bGwgOiBbbXNnLCBbZWxdXSkpO1xyXG5cclxuICAgICAgICBleHBvcnRzLmVsZW1lbnRGcm9tRW51bSA9IGFyckNvbnRhaW5zRWxDaGVjaygnZXJyb3JzLXVuc3VwcG9ydGVkLXR5cGUtaW4tbGlzdCcpO1xyXG4gICAgICAgIGV4cG9ydHMuZW50aXR5RXhpc3RzID0gYXJyQ29udGFpbnNFbENoZWNrKCdlcnJvcnMtZW50aXR5LWlzLW5vdC1leGlzdCcpO1xyXG5cclxuICAgICAgICBleHBvcnRzLmVudGl0eUlzTm90VXNlZCA9IFIuY3VycnkoKGVsLCB2YWx1ZUxpc3QpID0+XHJcbiAgICAgICAgICAgICgpID0+ICghUi5jb250YWlucyhlbCwgdmFsdWVMaXN0KSA/IG51bGwgOiBbJ2Vycm9ycy1lbnRpdHktaXMtdXNlZCcsIFtlbF1dKSk7XHJcblxyXG4gICAgICAgIGV4cG9ydHMuaXNTdHJpbmcgPSBSLmN1cnJ5KGVsID0+XHJcbiAgICAgICAgICAgICgpID0+IChSLmlzKFN0cmluZywgZWwpID8gbnVsbCA6IFsnZXJyb3JzLWFyZ3VtZW50LWlzLW5vdC1hLXN0cmluZycsIFtlbF1dKSk7XHJcblxyXG4gICAgICAgIGV4cG9ydHMuaXNFbXB0eVN0cmluZyA9IFIuY3VycnkoZWwgPT5cclxuICAgICAgICAgICAgKCkgPT4gKFIuZXF1YWxzKCcnLCBlbCkgPyBudWxsIDogWydlcnJvcnMtYXJndW1lbnQtaXMtbm90LWVtcHR5LXN0cmluZycsIFtlbF1dKSk7XHJcblxyXG4gICAgICAgIGV4cG9ydHMuaXNOb3RFbXB0eVN0cmluZyA9IFIuY3VycnkoZWwgPT5cclxuICAgICAgICAgICAgKCkgPT4gKCFSLmVxdWFscygnJywgZWwpID8gbnVsbCA6IFsnZXJyb3JzLWFyZ3VtZW50LWlzLWVtcHR5LXN0cmluZycsIFtlbF1dKSk7XHJcblxyXG4gICAgICAgIGV4cG9ydHMubmFtZUlzTm90RW1wdHkgPSBSLmN1cnJ5KGVsID0+XHJcbiAgICAgICAgICAgICgpID0+ICghUi5lcXVhbHMoJycsIGVsKSA/IG51bGwgOiBbJ2Vycm9ycy1uYW1lLWlzLWVtcHR5LXN0cmluZycsIFtlbF1dKSk7XHJcblxyXG4gICAgICAgIGV4cG9ydHMuaXNBcnJheSA9IFIuY3VycnkoZWwgPT5cclxuICAgICAgICAgICAgKCkgPT4gKFIuaXMoQXJyYXksIGVsKSA/IG51bGwgOiBbJ2Vycm9ycy1hcmd1bWVudC1pcy1ub3QtYW4tYXJyYXknLCBbZWxdXSkpO1xyXG5cclxuICAgICAgICBleHBvcnRzLmlzT2JqZWN0ID0gUi5jdXJyeShlbCA9PlxyXG4gICAgICAgICAgICAoKSA9PiAoUi5pcyhPYmplY3QsIGVsKSA/IG51bGwgOiBbJ2Vycm9ycy1hcmd1bWVudC1pcy1ub3QtYW4tb2JqZWN0JywgW2VsXV0pKTtcclxuXHJcbiAgICAgICAgZXhwb3J0cy5pc0Jvb2xlYW4gPSBSLmN1cnJ5KGVsID0+XHJcbiAgICAgICAgICAgICgpID0+IChSLmlzKEJvb2xlYW4sIGVsKSA/IG51bGwgOiBbJ2Vycm9ycy1hcmd1bWVudC1pcy1ub3QtYS1ib29sZWFuJywgW2VsXV0pKTtcclxuXHJcbiAgICAgICAgZXhwb3J0cy5pc051bWJlciA9IFIuY3VycnkoZWwgPT5cclxuICAgICAgICAgICAgKCkgPT4gKFIuaXMoTnVtYmVyLCBlbCkgPyBudWxsIDogWydlcnJvcnMtYXJndW1lbnQtaXMtbm90LWEtbnVtYmVyJywgW2VsXV0pKTtcclxuXHJcbiAgICAgICAgZXhwb3J0cy5pc05pbCA9IFIuY3VycnkoZWwgPT5cclxuICAgICAgICAgICAgKCkgPT4gKFIuaXNOaWwoZWwpID8gbnVsbCA6IFsnZXJyb3JzLWFyZ3VtZW50LWlzLW5vdC1uaWwnLCBbZWxdXSkpO1xyXG5cclxuICAgICAgICBleHBvcnRzLm5pbCA9IFIuY3VycnkoKCkgPT4gKCkgPT4gbnVsbCk7XHJcblxyXG4gICAgICAgIGV4cG9ydHMubm90RXF1YWxzID0gUi5jdXJyeSgoZWwsIGVsMikgPT5cclxuICAgICAgICAgICAgKCkgPT4gKCFSLmVxdWFscyhlbCwgZWwyKSA/IG51bGwgOiBbJ2Vycm9ycy1hcmd1bWVudC1tdXN0LW5vdC1iZS1lcXVhbCcsIFtlbF1dKSk7XHJcblxyXG4gICAgICAgIGV4cG9ydHMuZXF1YWxzID0gUi5jdXJyeSgoZWwsIGVsMikgPT5cclxuICAgICAgICAgICAgKCkgPT4gKFIuZXF1YWxzKGVsLCBlbDIpID8gbnVsbCA6IFsnZXJyb3JzLWFyZ3VtZW50cy1tdXN0LWJlLWVxdWFsJywgW2VsLCBlbDJdXSkpO1xyXG5cclxuICAgICAgICBleHBvcnRzLmlzSW5SYW5nZSA9IFIuY3VycnkoKGVsLCBsb3csIHVwKSA9PlxyXG4gICAgICAgICAgICAoKSA9PiAobG93IDw9IGVsICYmIGVsIDw9IHVwID8gbnVsbCA6IFsnZXJyb3JzLWFyZ3VtZW50LWlzLW5vdC1pbi1yYW5nZScsIFtlbCwgbG93LCB1cF1dKSk7XHJcblxyXG4gICAgICAgIGV4cG9ydHMuaXNOb25OZWdhdGl2ZSA9IFIuY3VycnkoZWwgPT5cclxuICAgICAgICAgICAgKCkgPT4gKGVsID49IDAgPyBudWxsIDogWydlcnJvcnMtYXJndW1lbnQtaXMtbmVnYXRpdmUnLCBbZWxdXSkpO1xyXG5cclxuICAgICAgICBleHBvcnRzLmNyZWF0ZUVudGl0eUNoZWNrID0gUi5jdXJyeSgoZW50aXR5TmFtZSwgZW50aXR5TGlzdCkgPT5cclxuICAgICAgICAgICAgZXhwb3J0cy5jaGFpbkNoZWNrKFtleHBvcnRzLmlzU3RyaW5nKGVudGl0eU5hbWUpLCBleHBvcnRzLm5hbWVJc05vdEVtcHR5KGVudGl0eU5hbWUpLFxyXG4gICAgICAgICAgICAgICAgZXhwb3J0cy5lbnRpdHlJc05vdFVzZWQoZW50aXR5TmFtZSwgZW50aXR5TGlzdCldKSk7XHJcblxyXG4gICAgICAgIGV4cG9ydHMucmVtb3ZlRW50aXR5Q2hlY2sgPSBSLmN1cnJ5KChlbnRpdHlOYW1lLCBlbnRpdHlMaXN0KSA9PlxyXG4gICAgICAgICAgICBleHBvcnRzLmNoYWluQ2hlY2soW2V4cG9ydHMuaXNTdHJpbmcoZW50aXR5TmFtZSksIGV4cG9ydHMuZW50aXR5RXhpc3RzKGVudGl0eU5hbWUsIGVudGl0eUxpc3QpXSkpO1xyXG5cclxuICAgICAgICBleHBvcnRzLmVudGl0eUV4aXN0c0NoZWNrID0gZXhwb3J0cy5yZW1vdmVFbnRpdHlDaGVjaztcclxuXHJcbiAgICAgICAgZXhwb3J0cy5yZW5hbWVFbnRpdHlDaGVjayA9IFIuY3VycnkoKGZyb21OYW1lLCB0b05hbWUsIGVudGl0eUxpc3QpID0+XHJcbiAgICAgICAgICAgIGV4cG9ydHMuY2hhaW5DaGVjayhbZXhwb3J0cy5yZW1vdmVFbnRpdHlDaGVjayhmcm9tTmFtZSwgZW50aXR5TGlzdCksXHJcbiAgICAgICAgICAgICAgICBleHBvcnRzLmNyZWF0ZUVudGl0eUNoZWNrKHRvTmFtZSwgZW50aXR5TGlzdCldKSk7XHJcblxyXG4gICAgICAgIGV4cG9ydHMuc3dpdGNoRW50aXR5Q2hlY2sgPSBSLmN1cnJ5KChlbnRpdHkxLCBlbnRpdHkyLCBlbnRpdHlMaXN0LCBlbnRpdHlDb250YWluZXJMaXN0KSA9PlxyXG4gICAgICAgICAgICBleHBvcnRzLmNoYWluQ2hlY2soW2V4cG9ydHMuZW50aXR5RXhpc3RzQ2hlY2soZW50aXR5MSwgZW50aXR5TGlzdCksXHJcbiAgICAgICAgICAgICAgICBleHBvcnRzLmVudGl0eUV4aXN0c0NoZWNrKGVudGl0eTIsIGVudGl0eUxpc3QpLFxyXG4gICAgICAgICAgICAgICAgZXhwb3J0cy5lbnRpdHlFeGlzdHMoZW50aXR5MSwgZW50aXR5Q29udGFpbmVyTGlzdCksXHJcbiAgICAgICAgICAgICAgICBleHBvcnRzLmVudGl0eUlzTm90VXNlZChlbnRpdHkyLCBlbnRpdHlDb250YWluZXJMaXN0KV0pKTtcclxuXHJcbiAgICAgICAgZXhwb3J0cy5wYXR0ZXJuQ2hlY2sgPSBSLmN1cnJ5KChlbCwgcmVnZXgpID0+ICgpID0+XHJcbiAgICAgICAgICAgIChyZWdleC50ZXN0KGVsKSA/IG51bGwgOiBbJ2Vycm9ycy1hcmd1bWVudC1kb2VzbnQtbWF0Y2gtcGF0dGVybicsIFtlbCwgcmVnZXgudG9TdHJpbmcoKV1dKSk7XHJcblxyXG4gICAgICAgIGV4cG9ydHMuYXJyYXlDaGVjayA9IFIuY3VycnkoKGFyciwgY2hlY2spID0+IGV4cG9ydHMuY2hhaW5DaGVjayhhcnIubWFwKGNoZWNrKSkpO1xyXG5cclxuICAgICAgICBleHBvcnRzLmdldFZhbHVlQ2hlY2sgPSAodHlwZSkgPT4ge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcclxuICAgICAgICAgICAgY2FzZSAnY2hlY2tib3gnOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuaXNCb29sZWFuO1xyXG4gICAgICAgICAgICBjYXNlICdudW1iZXInOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4cG9ydHMuaXNOdW1iZXI7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5pc1N0cmluZztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgY2FsbGJhY2syKFByZWNvbmRpdGlvbik7XHJcbn0pKGFwaSA9PiAoKHR5cGVvZiBleHBvcnRzID09PSAndW5kZWZpbmVkJykgPyBhcGkoKHRoaXMuUHJlY29uZGl0aW9uID0ge30pLCBSLCBFcnJvcnMpIDogKG1vZHVsZS5leHBvcnRzID0gYXBpKSkpO1xyXG4iLCIvKlxyXG4gICAgRGF0ZSBGb3JtYXQgMS4yLjNcclxuICAgIChjKSAyMDA3LTIwMDkgU3RldmVuIExldml0aGFuIDxzdGV2ZW5sZXZpdGhhbi5jb20+XHJcbiAgICBNSVQgbGljZW5zZVxyXG5cclxuICAgIEluY2x1ZGVzIGVuaGFuY2VtZW50cyBieSBTY290dCBUcmVuZGEgPHNjb3R0LnRyZW5kYS5uZXQ+XHJcbiAgICBhbmQgS3JpcyBLb3dhbCA8Y2l4YXIuY29tL35rcmlzLmtvd2FsLz5cclxuXHJcbiAgICBBY2NlcHRzIGEgZGF0ZSwgYSBtYXNrLCBvciBhIGRhdGUgYW5kIGEgbWFzay5cclxuICAgIFJldHVybnMgYSBmb3JtYXR0ZWQgdmVyc2lvbiBvZiB0aGUgZ2l2ZW4gZGF0ZS5cclxuICAgIFRoZSBkYXRlIGRlZmF1bHRzIHRvIHRoZSBjdXJyZW50IGRhdGUvdGltZS5cclxuICAgIFRoZSBtYXNrIGRlZmF1bHRzIHRvIGRhdGVGb3JtYXQubWFza3MuZGVmYXVsdC5cclxuKi9cclxuXHJcbi8vIFRoYW5rcyBmb3IgeW91ciB3b3JrIDspXHJcbi8vIE50c0RLXHJcblxyXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xyXG5cclxuKGZ1bmN0aW9uIChjYWxsYmFjaykge1xyXG4gICAgdmFyIGRhdGVGb3JtYXQgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGxldCB0b2tlbiA9IC9kezEsNH18bXsxLDR9fHl5KD86eXkpP3woW0hoTXNUdF0pXFwxP3xbTGxvU1pdfFwiW15cIl0qXCJ8J1teJ10qJy9nLFxyXG4gICAgICAgICAgICB0aW1lem9uZSA9IC9cXGIoPzpbUE1DRUFdW1NEUF1UfCg/OlBhY2lmaWN8TW91bnRhaW58Q2VudHJhbHxFYXN0ZXJufEF0bGFudGljKSAoPzpTdGFuZGFyZHxEYXlsaWdodHxQcmV2YWlsaW5nKSBUaW1lfCg/OkdNVHxVVEMpKD86Wy0rXVxcZHs0fSk/KVxcYi9nLFxyXG4gICAgICAgICAgICB0aW1lem9uZUNsaXAgPSAvW14tK1xcZEEtWl0vZyxcclxuICAgICAgICAgICAgcGFkID0gZnVuY3Rpb24gKHZhbCwgbGVuKSB7XHJcbiAgICAgICAgICAgICAgICB2YWwgPSBTdHJpbmcodmFsKTtcclxuICAgICAgICAgICAgICAgIGxlbiA9IGxlbiB8fCAyO1xyXG4gICAgICAgICAgICAgICAgd2hpbGUgKHZhbC5sZW5ndGggPCBsZW4pIHZhbCA9IGAwJHt2YWx9YDtcclxuICAgICAgICAgICAgICAgIHJldHVybiB2YWw7XHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIFJlZ2V4ZXMgYW5kIHN1cHBvcnRpbmcgZnVuY3Rpb25zIGFyZSBjYWNoZWQgdGhyb3VnaCBjbG9zdXJlXHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChkYXRlLCBtYXNrLCB1dGMpIHtcclxuICAgICAgICAgICAgY29uc3QgZEYgPSBkYXRlRm9ybWF0O1xyXG5cclxuICAgICAgICAgICAgLy8gWW91IGNhbid0IHByb3ZpZGUgdXRjIGlmIHlvdSBza2lwIG90aGVyIGFyZ3MgKHVzZSB0aGUgXCJVVEM6XCIgbWFzayBwcmVmaXgpXHJcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09IDEgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGRhdGUpID09ICdbb2JqZWN0IFN0cmluZ10nICYmICEvXFxkLy50ZXN0KGRhdGUpKSB7XHJcbiAgICAgICAgICAgICAgICBtYXNrID0gZGF0ZTtcclxuICAgICAgICAgICAgICAgIGRhdGUgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIC8vIFBhc3NpbmcgZGF0ZSB0aHJvdWdoIERhdGUgYXBwbGllcyBEYXRlLnBhcnNlLCBpZiBuZWNlc3NhcnlcclxuICAgICAgICAgICAgZGF0ZSA9IGRhdGUgPyBuZXcgRGF0ZShkYXRlKSA6IG5ldyBEYXRlKCk7XHJcbiAgICAgICAgICAgIGlmIChpc05hTihkYXRlKSkgdGhyb3cgU3ludGF4RXJyb3IoJ2ludmFsaWQgZGF0ZScpO1xyXG5cclxuICAgICAgICAgICAgbWFzayA9IFN0cmluZyhkRi5tYXNrc1ttYXNrXSB8fCBtYXNrIHx8IGRGLm1hc2tzLmRlZmF1bHQpO1xyXG5cclxuICAgICAgICAgICAgLy8gQWxsb3cgc2V0dGluZyB0aGUgdXRjIGFyZ3VtZW50IHZpYSB0aGUgbWFza1xyXG4gICAgICAgICAgICBpZiAobWFzay5zbGljZSgwLCA0KSA9PSAnVVRDOicpIHtcclxuICAgICAgICAgICAgICAgIG1hc2sgPSBtYXNrLnNsaWNlKDQpO1xyXG4gICAgICAgICAgICAgICAgdXRjID0gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgbGV0IF8gPSB1dGMgPyAnZ2V0VVRDJyA6ICdnZXQnLFxyXG4gICAgICAgICAgICAgICAgZCA9IGRhdGVbYCR7X31EYXRlYF0oKSxcclxuICAgICAgICAgICAgICAgIEQgPSBkYXRlW2Ake199RGF5YF0oKSxcclxuICAgICAgICAgICAgICAgIG0gPSBkYXRlW2Ake199TW9udGhgXSgpLFxyXG4gICAgICAgICAgICAgICAgeSA9IGRhdGVbYCR7X31GdWxsWWVhcmBdKCksXHJcbiAgICAgICAgICAgICAgICBIID0gZGF0ZVtgJHtffUhvdXJzYF0oKSxcclxuICAgICAgICAgICAgICAgIE0gPSBkYXRlW2Ake199TWludXRlc2BdKCksXHJcbiAgICAgICAgICAgICAgICBzID0gZGF0ZVtgJHtffVNlY29uZHNgXSgpLFxyXG4gICAgICAgICAgICAgICAgTCA9IGRhdGVbYCR7X31NaWxsaXNlY29uZHNgXSgpLFxyXG4gICAgICAgICAgICAgICAgbyA9IHV0YyA/IDAgOiBkYXRlLmdldFRpbWV6b25lT2Zmc2V0KCksXHJcbiAgICAgICAgICAgICAgICBmbGFncyA9IHtcclxuICAgICAgICAgICAgICAgICAgICBkLFxyXG4gICAgICAgICAgICAgICAgICAgIGRkOiBwYWQoZCksXHJcbiAgICAgICAgICAgICAgICAgICAgZGRkOiBkRi5pMThuLmRheU5hbWVzW0RdLFxyXG4gICAgICAgICAgICAgICAgICAgIGRkZGQ6IGRGLmkxOG4uZGF5TmFtZXNbRCArIDddLFxyXG4gICAgICAgICAgICAgICAgICAgIG06IG0gKyAxLFxyXG4gICAgICAgICAgICAgICAgICAgIG1tOiBwYWQobSArIDEpLFxyXG4gICAgICAgICAgICAgICAgICAgIG1tbTogZEYuaTE4bi5tb250aE5hbWVzW21dLFxyXG4gICAgICAgICAgICAgICAgICAgIG1tbW06IGRGLmkxOG4ubW9udGhOYW1lc1ttICsgMTJdLFxyXG4gICAgICAgICAgICAgICAgICAgIHl5OiBTdHJpbmcoeSkuc2xpY2UoMiksXHJcbiAgICAgICAgICAgICAgICAgICAgeXl5eTogeSxcclxuICAgICAgICAgICAgICAgICAgICBoOiBIICUgMTIgfHwgMTIsXHJcbiAgICAgICAgICAgICAgICAgICAgaGg6IHBhZChIICUgMTIgfHwgMTIpLFxyXG4gICAgICAgICAgICAgICAgICAgIEgsXHJcbiAgICAgICAgICAgICAgICAgICAgSEg6IHBhZChIKSxcclxuICAgICAgICAgICAgICAgICAgICBNLFxyXG4gICAgICAgICAgICAgICAgICAgIE1NOiBwYWQoTSksXHJcbiAgICAgICAgICAgICAgICAgICAgcyxcclxuICAgICAgICAgICAgICAgICAgICBzczogcGFkKHMpLFxyXG4gICAgICAgICAgICAgICAgICAgIGw6IHBhZChMLCAzKSxcclxuICAgICAgICAgICAgICAgICAgICBMOiBwYWQoTCA+IDk5ID8gTWF0aC5yb3VuZChMIC8gMTApIDogTCksXHJcbiAgICAgICAgICAgICAgICAgICAgdDogSCA8IDEyID8gJ2EnIDogJ3AnLFxyXG4gICAgICAgICAgICAgICAgICAgIHR0OiBIIDwgMTIgPyAnYW0nIDogJ3BtJyxcclxuICAgICAgICAgICAgICAgICAgICBUOiBIIDwgMTIgPyAnQScgOiAnUCcsXHJcbiAgICAgICAgICAgICAgICAgICAgVFQ6IEggPCAxMiA/ICdBTScgOiAnUE0nLFxyXG4gICAgICAgICAgICAgICAgICAgIFo6IHV0YyA/ICdVVEMnIDogKFN0cmluZyhkYXRlKS5tYXRjaCh0aW1lem9uZSkgfHwgWycnXSkucG9wKCkucmVwbGFjZSh0aW1lem9uZUNsaXAsICcnKSxcclxuICAgICAgICAgICAgICAgICAgICBvOiAobyA+IDAgPyAnLScgOiAnKycpICsgcGFkKE1hdGguZmxvb3IoTWF0aC5hYnMobykgLyA2MCkgKiAxMDAgKyBNYXRoLmFicyhvKSAlIDYwLCA0KSxcclxuICAgICAgICAgICAgICAgICAgICBTOiBbJ3RoJywgJ3N0JywgJ25kJywgJ3JkJ11bZCAlIDEwID4gMyA/IDAgOiAoZCAlIDEwMCAtIGQgJSAxMCAhPSAxMCkgKiBkICUgMTBdXHJcbiAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgcmV0dXJuIG1hc2sucmVwbGFjZSh0b2tlbiwgJDAgPT4gKCQwIGluIGZsYWdzID8gZmxhZ3NbJDBdIDogJDAuc2xpY2UoMSwgJDAubGVuZ3RoIC0gMSkpKTtcclxuICAgICAgICB9O1xyXG4gICAgfSgpKTtcclxuXHJcbiAgICAvLyBTb21lIGNvbW1vbiBmb3JtYXQgc3RyaW5nc1xyXG4gICAgZGF0ZUZvcm1hdC5tYXNrcyA9IHtcclxuICAgICAgICBkZWZhdWx0OiAnZGRkIG1tbSBkZCB5eXl5IEhIOk1NOnNzJyxcclxuICAgICAgICBzaG9ydERhdGU6ICdtL2QveXknLFxyXG4gICAgICAgIG1lZGl1bURhdGU6ICdtbW0gZCwgeXl5eScsXHJcbiAgICAgICAgbG9uZ0RhdGU6ICdtbW1tIGQsIHl5eXknLFxyXG4gICAgICAgIGZ1bGxEYXRlOiAnZGRkZCwgbW1tbSBkLCB5eXl5JyxcclxuICAgICAgICBzaG9ydFRpbWU6ICdoOk1NIFRUJyxcclxuICAgICAgICBtZWRpdW1UaW1lOiAnaDpNTTpzcyBUVCcsXHJcbiAgICAgICAgbG9uZ1RpbWU6ICdoOk1NOnNzIFRUIFonLFxyXG4gICAgICAgIGlzb0RhdGU6ICd5eXl5LW1tLWRkJyxcclxuICAgICAgICBpc29UaW1lOiAnSEg6TU06c3MnLFxyXG4gICAgICAgIGlzb0RhdGVUaW1lOiAneXl5eS1tbS1kZFxcJ1RcXCdISDpNTTpzcycsXHJcbiAgICAgICAgaXNvVXRjRGF0ZVRpbWU6ICdVVEM6eXl5eS1tbS1kZFxcJ1RcXCdISDpNTTpzc1xcJ1pcXCcnXHJcbiAgICB9O1xyXG5cclxuICAgIC8vIEludGVybmF0aW9uYWxpemF0aW9uIHN0cmluZ3NcclxuICAgIGRhdGVGb3JtYXQuaTE4biA9IHtcclxuICAgICAgICBkYXlOYW1lczogW1xyXG4gICAgICAgICAgICAnU3VuJywgJ01vbicsICdUdWUnLCAnV2VkJywgJ1RodScsICdGcmknLCAnU2F0JyxcclxuICAgICAgICAgICAgJ1N1bmRheScsICdNb25kYXknLCAnVHVlc2RheScsICdXZWRuZXNkYXknLCAnVGh1cnNkYXknLCAnRnJpZGF5JywgJ1NhdHVyZGF5J1xyXG4gICAgICAgIF0sXHJcbiAgICAgICAgbW9udGhOYW1lczogW1xyXG4gICAgICAgICAgICAnSmFuJywgJ0ZlYicsICdNYXInLCAnQXByJywgJ01heScsICdKdW4nLCAnSnVsJywgJ0F1ZycsICdTZXAnLCAnT2N0JywgJ05vdicsICdEZWMnLFxyXG4gICAgICAgICAgICAnSmFudWFyeScsICdGZWJydWFyeScsICdNYXJjaCcsICdBcHJpbCcsICdNYXknLCAnSnVuZScsICdKdWx5JywgJ0F1Z3VzdCcsICdTZXB0ZW1iZXInLCAnT2N0b2JlcicsICdOb3ZlbWJlcicsICdEZWNlbWJlcidcclxuICAgICAgICBdXHJcbiAgICB9O1xyXG5cclxuICAgIGNhbGxiYWNrKGRhdGVGb3JtYXQpO1xyXG59KGRhdGVGb3JtYXQgPT4gKCh0eXBlb2YgZXhwb3J0cyA9PT0gJ3VuZGVmaW5lZCcpID8gKHRoaXMuZGF0ZUZvcm1hdCA9IGRhdGVGb3JtYXQpIDogKG1vZHVsZS5leHBvcnRzID0gZGF0ZUZvcm1hdCkpKSk7XHJcbiIsInZhciBkZWZhdWx0TGFuZyA9ICdydSc7XHJcbiJdLCJzb3VyY2VSb290IjoiL3NvdXJjZS8ifQ==

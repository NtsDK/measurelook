/*Copyright 2017 Timofey Rechkalov <ntsdk@yandex.ru>

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
    limitations under the License. */

'use strict';

((exports) => {
    const l10n = L10n.get('performance');
    const root = '.performance-tab ';
    const state = {};

    exports.init = () => {
        listen(getEl('chartDataSelector'), 'change', onSettingsChange);
        const checkboxes = ['showRawData', 'showAvgData', 'showMedianData', 'showYLogData', 'showXLogData', 
            'maxXEnabled', 'minXEnabled', 'maxYEnabled', 'minYEnabled'];
        
        checkboxes.forEach(R.pipe(getEl, listen(R.__, 'change', onSettingsChange)));
        checkboxes.forEach(R.pipe(getEl, setProp(R.__, 'checked', false)));
        getEl('showMedianData').checked = true;
        listen(queryEl(`${root}.download-csv-button`), 'click', () => FileUtils.arr2d2Csv(state.data, 'table.csv'));
        
        const inputs = ['maxX', 'minX', 'maxY', 'minY'];
        inputs.forEach(R.pipe(getEl, listen(R.__, 'input', onSettingsChange)));

        exports.content = queryEl(root);
    };

    function paramTitle(param) {
        return `${param.name}, ${param.units}`;
    }

    const makeRow = R.curry((arr) => {
        const str2el = (value) => addEl(makeEl('td'), makeText(value || ''));
        return addEls(makeEl('tr'), arr.map(str2el));
    });

    const metaComparator = CommonUtils.charOrdAFactory(a => a[0].toLowerCase());
    const paramComparator = CommonUtils.charOrdAFactory(a => a.name.toLowerCase());
    
    exports.refresh = () => {
        DBMS.getDatabase((err, database) => {
            if (err) { Utils.handleError(err); return; }

            addEls(clearEl(queryEl(root + '#metainformation-table tbody')), 
                    R.toPairs(database.meta).sort(metaComparator).map(makeRow));
            addEls(clearEl(queryEl(root + '#constants-table tbody')), database.constantParams.sort(paramComparator)
                    .map(R.pipe(R.props(['name', 'units', 'value']), makeRow)));
            addEls(clearEl(queryEl(root + '#changed-params-table tbody')), database.changedParams.sort(paramComparator)
                    .map(R.pipe(R.props(['name', 'units']), makeRow)));
            addEls(clearEl(queryEl(root + '#measured-params-table tbody')), database.measuredParams.sort(paramComparator)
                    .map(R.pipe(R.props(['name', 'units', 'type', 'sumOf']), makeRow)));

            fillSelector(clearEl(getEl('chartDataSelector')), database.measuredParams.sort(paramComparator).map(val => ({
                name: val.name,
                value: val.name,
                selected: true
            })));
            setAttr(getEl('chartDataSelector'), 'size', Math.min(20, database.measuredParams.length));

            onSettingsChange();
        });
    };

    function onSettingsChange() {
        const measuredParamsList = nl2array(getEl('chartDataSelector').selectedOptions).map(R.prop('value'));

        DBMS.getDatabase((err, database) => {
            drawChart(database, measuredParamsList, {
                drawRaw: getEl('showRawData').checked,
                drawAvg: getEl('showAvgData').checked,
                drawMedian: getEl('showMedianData').checked,
                drawYLog: getEl('showYLogData').checked,
                drawXLog: getEl('showXLogData').checked,
                maxX: getEl('maxXEnabled').checked ? Number(getEl('maxX').value) : null,
                minX: getEl('minXEnabled').checked ? Number(getEl('minX').value) : null,
                maxY: getEl('maxYEnabled').checked ? Number(getEl('maxY').value) : null,
                minY: getEl('minYEnabled').checked ? Number(getEl('minY').value) : null,
            });
        });
    }

    function drawChart(database, measuredParamsList, opts) {
        const changedParam = database.changedParams[0];
        let data = [];
        const xScaler = opts.drawXLog ? Math.log : R.identity;
//        const xScaler = R.identity;
        const yScaler = opts.drawYLog ? Math.log : R.identity;

        const measuredParams = R.filter(R.compose(R.contains(R.__, measuredParamsList), R.prop('name')), database.measuredParams);

        if (opts.drawRaw) {
            const rawData = R.flatten(measuredParams.map(makeRawDataLines(xScaler, yScaler, database, changedParam)));
            data = data.concat(rawData);
        }

        if (opts.drawAvg) {
            const avgData = R.flatten(measuredParams.map(makeAvgDataLines(xScaler, yScaler, database, changedParam)));
            data = data.concat(avgData);
        }

        if (opts.drawMedian) {
            data = data.concat(R.flatten(measuredParams.map(makeMedianDataLines(xScaler, yScaler, database, changedParam))));
        }


        const chart = new CanvasJS.Chart('chartContainer', {
            zoomEnabled: true, 
            zoomType: "xy",
            exportEnabled: true,
//            interactivityEnabled: true,
            axisX: {
                title: paramTitle(changedParam),
                titleFontSize: 18,
                minimum: opts.minX,
                maximum: opts.maxX,
            },
            axisY: {
                title: paramTitle(database.measuredParams[0]),
                titleFontSize: 16,
                minimum: opts.minY,
                maximum: opts.maxY,
            },
            legend: {
                verticalAlign: 'bottom',
                horizontalAlign: 'center'
            },

            data
        });

        chart.render();

        fillDataTable(data);
    }

    function fillDataTable(data) {
        const thead = clearEl(queryEl(`${root}.table-panel table thead`));
        const tbody = clearEl(queryEl(`${root}.table-panel table tbody`));

        const data2 = [];

        const keys = ['track name', 'units'].concat(data[0].dataPoints.map(R.prop('x')));
        data2.push(keys);
        addEl(thead, addEls(makeEl('tr'), keys.map(makeText).map(el => addEl(makeEl('th'), el))));

        addEls(tbody, data.map((row) => {
            const vals = [row.legendText, row.units].concat(row.dataPoints.map(R.prop('y')));
            data2.push(vals);
            return addEls(makeEl('tr'), vals.map(makeText).map(el => addEl(makeEl('td'), el)));
        }));
        state.data = data2;
    }


    // eslint-disable-next-line no-var,vars-on-top
    var makeRawDataLines = R.curry((xScaler, yScaler, database, changedParam, measuredParam) => {
        const passes = R.groupBy(item => item.passId, R.values(database.measures));

        const dataPoints = R.map(passArray => passArray.map(item => ({
            x: xScaler(item[changedParam.name]),
            y: yScaler(item[measuredParam.name]),
            toolTipContent: L10n.format(
                'performance', 'tooltip-schema',
                [
                    measuredParam.name,
                    item.passId,
                    paramTitle(changedParam),
                    item[changedParam.name],
                    paramTitle(measuredParam),
                    item[measuredParam.name]
                ]
            )
        })), passes);

        return R.values(R.mapObjIndexed((array, key) => ({
            showInLegend: true,
            legendText: `${measuredParam.name} ${key}`,
            type: 'line',
            markerType: 'circle',
            markerBorderColor: 'black',
            markerSize: 15,
            markerBorderThickness: 1,
            units: measuredParam.units,
            dataPoints: array
        }), dataPoints));
    });

    const makeAggregatedDataLines =
        R.curry((label, aggregationFunction, xScaler, yScaler, database, changedParam, measuredParam) => {
            const pointed = R.groupBy(item => item[changedParam.name], R.values(database.measures));

            let avg = R.map((value) => {
                const clone = R.clone(value[0]);
                const rawValues = R.ap([R.prop(measuredParam.name)], value).sort();
                clone[measuredParam.name] = yScaler(aggregationFunction(rawValues));
                clone.yDisplayName = aggregationFunction(rawValues);
                clone[changedParam.name] = xScaler(value[0][changedParam.name]);
                clone.xDisplayName = value[0][changedParam.name];
                return clone;
            }, pointed);

            avg = R.values(avg).map(item => ({
                x: item[changedParam.name],
                y: item[measuredParam.name],
                toolTipContent: strFormat(
                    '{0}: {1}<br/>{2}: {3}',
                    [paramTitle(changedParam),
                        item[changedParam.name] + ' (raw value ' + item.xDisplayName + ')',
                        paramTitle(measuredParam),
                        item[measuredParam.name] + ' (raw value ' + item.yDisplayName + ')']
                )
            }));

            return {
                showInLegend: true,
                legendText: `${measuredParam.name} ${label}`,
                type: 'line',
                markerType: 'circle',
                markerBorderColor: 'black',
                markerSize: 30,
                markerBorderThickness: 1,
                units: measuredParam.units,
                dataPoints: avg
            };
        });

    // eslint-disable-next-line no-var,vars-on-top
    var makeMedianDataLines = makeAggregatedDataLines('median', R.median);
    // eslint-disable-next-line no-var,vars-on-top
    var makeAvgDataLines = makeAggregatedDataLines('avg', R.mean);
})(this.Performance = {});

/*Copyright 2017 Timofey Rechkalov <ntsdk@yandex.ru>

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
    limitations under the License. */

'use strict';

((exports) => {
    const root = '.-tab ';
    const state = {};

    exports.init = () => {
        exports.content = queryEl(root);
    };

    exports.refresh = () => {

    };
})(this.Template = {});

/*Copyright 2017 Timofey Rechkalov <ntsdk@yandex.ru>

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
    limitations under the License. */

'use strict';

((exports) => {
    exports.init = () => {
        exports.content = getEl('aboutDiv');
    };

    exports.refresh = () => {
    };
})(this.About = {});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImpzL3BhZ2VzL3BlcmZvcm1hbmNlLmpzIiwianMvcGFnZXMvdGVtcGxhdGUuanMiLCJqcy9wYWdlcy9sb2dzL2Fib3V0LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNqUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJwYWdlcy5taW4uanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKkNvcHlyaWdodCAyMDE3IFRpbW9mZXkgUmVjaGthbG92IDxudHNka0B5YW5kZXgucnU+XHJcblxyXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG5cclxuaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICAgIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuKChleHBvcnRzKSA9PiB7XHJcbiAgICBjb25zdCBsMTBuID0gTDEwbi5nZXQoJ3BlcmZvcm1hbmNlJyk7XHJcbiAgICBjb25zdCByb290ID0gJy5wZXJmb3JtYW5jZS10YWIgJztcclxuICAgIGNvbnN0IHN0YXRlID0ge307XHJcblxyXG4gICAgZXhwb3J0cy5pbml0ID0gKCkgPT4ge1xyXG4gICAgICAgIGxpc3RlbihnZXRFbCgnY2hhcnREYXRhU2VsZWN0b3InKSwgJ2NoYW5nZScsIG9uU2V0dGluZ3NDaGFuZ2UpO1xyXG4gICAgICAgIGNvbnN0IGNoZWNrYm94ZXMgPSBbJ3Nob3dSYXdEYXRhJywgJ3Nob3dBdmdEYXRhJywgJ3Nob3dNZWRpYW5EYXRhJywgJ3Nob3dZTG9nRGF0YScsICdzaG93WExvZ0RhdGEnLCBcclxuICAgICAgICAgICAgJ21heFhFbmFibGVkJywgJ21pblhFbmFibGVkJywgJ21heFlFbmFibGVkJywgJ21pbllFbmFibGVkJ107XHJcbiAgICAgICAgXHJcbiAgICAgICAgY2hlY2tib3hlcy5mb3JFYWNoKFIucGlwZShnZXRFbCwgbGlzdGVuKFIuX18sICdjaGFuZ2UnLCBvblNldHRpbmdzQ2hhbmdlKSkpO1xyXG4gICAgICAgIGNoZWNrYm94ZXMuZm9yRWFjaChSLnBpcGUoZ2V0RWwsIHNldFByb3AoUi5fXywgJ2NoZWNrZWQnLCBmYWxzZSkpKTtcclxuICAgICAgICBnZXRFbCgnc2hvd01lZGlhbkRhdGEnKS5jaGVja2VkID0gdHJ1ZTtcclxuICAgICAgICBsaXN0ZW4ocXVlcnlFbChgJHtyb290fS5kb3dubG9hZC1jc3YtYnV0dG9uYCksICdjbGljaycsICgpID0+IEZpbGVVdGlscy5hcnIyZDJDc3Yoc3RhdGUuZGF0YSwgJ3RhYmxlLmNzdicpKTtcclxuICAgICAgICBcclxuICAgICAgICBjb25zdCBpbnB1dHMgPSBbJ21heFgnLCAnbWluWCcsICdtYXhZJywgJ21pblknXTtcclxuICAgICAgICBpbnB1dHMuZm9yRWFjaChSLnBpcGUoZ2V0RWwsIGxpc3RlbihSLl9fLCAnaW5wdXQnLCBvblNldHRpbmdzQ2hhbmdlKSkpO1xyXG5cclxuICAgICAgICBleHBvcnRzLmNvbnRlbnQgPSBxdWVyeUVsKHJvb3QpO1xyXG4gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBwYXJhbVRpdGxlKHBhcmFtKSB7XHJcbiAgICAgICAgcmV0dXJuIGAke3BhcmFtLm5hbWV9LCAke3BhcmFtLnVuaXRzfWA7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgbWFrZVJvdyA9IFIuY3VycnkoKGFycikgPT4ge1xyXG4gICAgICAgIGNvbnN0IHN0cjJlbCA9ICh2YWx1ZSkgPT4gYWRkRWwobWFrZUVsKCd0ZCcpLCBtYWtlVGV4dCh2YWx1ZSB8fCAnJykpO1xyXG4gICAgICAgIHJldHVybiBhZGRFbHMobWFrZUVsKCd0cicpLCBhcnIubWFwKHN0cjJlbCkpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgbWV0YUNvbXBhcmF0b3IgPSBDb21tb25VdGlscy5jaGFyT3JkQUZhY3RvcnkoYSA9PiBhWzBdLnRvTG93ZXJDYXNlKCkpO1xyXG4gICAgY29uc3QgcGFyYW1Db21wYXJhdG9yID0gQ29tbW9uVXRpbHMuY2hhck9yZEFGYWN0b3J5KGEgPT4gYS5uYW1lLnRvTG93ZXJDYXNlKCkpO1xyXG4gICAgXHJcbiAgICBleHBvcnRzLnJlZnJlc2ggPSAoKSA9PiB7XHJcbiAgICAgICAgREJNUy5nZXREYXRhYmFzZSgoZXJyLCBkYXRhYmFzZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZXJyKSB7IFV0aWxzLmhhbmRsZUVycm9yKGVycik7IHJldHVybjsgfVxyXG5cclxuICAgICAgICAgICAgYWRkRWxzKGNsZWFyRWwocXVlcnlFbChyb290ICsgJyNtZXRhaW5mb3JtYXRpb24tdGFibGUgdGJvZHknKSksIFxyXG4gICAgICAgICAgICAgICAgICAgIFIudG9QYWlycyhkYXRhYmFzZS5tZXRhKS5zb3J0KG1ldGFDb21wYXJhdG9yKS5tYXAobWFrZVJvdykpO1xyXG4gICAgICAgICAgICBhZGRFbHMoY2xlYXJFbChxdWVyeUVsKHJvb3QgKyAnI2NvbnN0YW50cy10YWJsZSB0Ym9keScpKSwgZGF0YWJhc2UuY29uc3RhbnRQYXJhbXMuc29ydChwYXJhbUNvbXBhcmF0b3IpXHJcbiAgICAgICAgICAgICAgICAgICAgLm1hcChSLnBpcGUoUi5wcm9wcyhbJ25hbWUnLCAndW5pdHMnLCAndmFsdWUnXSksIG1ha2VSb3cpKSk7XHJcbiAgICAgICAgICAgIGFkZEVscyhjbGVhckVsKHF1ZXJ5RWwocm9vdCArICcjY2hhbmdlZC1wYXJhbXMtdGFibGUgdGJvZHknKSksIGRhdGFiYXNlLmNoYW5nZWRQYXJhbXMuc29ydChwYXJhbUNvbXBhcmF0b3IpXHJcbiAgICAgICAgICAgICAgICAgICAgLm1hcChSLnBpcGUoUi5wcm9wcyhbJ25hbWUnLCAndW5pdHMnXSksIG1ha2VSb3cpKSk7XHJcbiAgICAgICAgICAgIGFkZEVscyhjbGVhckVsKHF1ZXJ5RWwocm9vdCArICcjbWVhc3VyZWQtcGFyYW1zLXRhYmxlIHRib2R5JykpLCBkYXRhYmFzZS5tZWFzdXJlZFBhcmFtcy5zb3J0KHBhcmFtQ29tcGFyYXRvcilcclxuICAgICAgICAgICAgICAgICAgICAubWFwKFIucGlwZShSLnByb3BzKFsnbmFtZScsICd1bml0cycsICd0eXBlJywgJ3N1bU9mJ10pLCBtYWtlUm93KSkpO1xyXG5cclxuICAgICAgICAgICAgZmlsbFNlbGVjdG9yKGNsZWFyRWwoZ2V0RWwoJ2NoYXJ0RGF0YVNlbGVjdG9yJykpLCBkYXRhYmFzZS5tZWFzdXJlZFBhcmFtcy5zb3J0KHBhcmFtQ29tcGFyYXRvcikubWFwKHZhbCA9PiAoe1xyXG4gICAgICAgICAgICAgICAgbmFtZTogdmFsLm5hbWUsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsLm5hbWUsXHJcbiAgICAgICAgICAgICAgICBzZWxlY3RlZDogdHJ1ZVxyXG4gICAgICAgICAgICB9KSkpO1xyXG4gICAgICAgICAgICBzZXRBdHRyKGdldEVsKCdjaGFydERhdGFTZWxlY3RvcicpLCAnc2l6ZScsIE1hdGgubWluKDIwLCBkYXRhYmFzZS5tZWFzdXJlZFBhcmFtcy5sZW5ndGgpKTtcclxuXHJcbiAgICAgICAgICAgIG9uU2V0dGluZ3NDaGFuZ2UoKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gb25TZXR0aW5nc0NoYW5nZSgpIHtcclxuICAgICAgICBjb25zdCBtZWFzdXJlZFBhcmFtc0xpc3QgPSBubDJhcnJheShnZXRFbCgnY2hhcnREYXRhU2VsZWN0b3InKS5zZWxlY3RlZE9wdGlvbnMpLm1hcChSLnByb3AoJ3ZhbHVlJykpO1xyXG5cclxuICAgICAgICBEQk1TLmdldERhdGFiYXNlKChlcnIsIGRhdGFiYXNlKSA9PiB7XHJcbiAgICAgICAgICAgIGRyYXdDaGFydChkYXRhYmFzZSwgbWVhc3VyZWRQYXJhbXNMaXN0LCB7XHJcbiAgICAgICAgICAgICAgICBkcmF3UmF3OiBnZXRFbCgnc2hvd1Jhd0RhdGEnKS5jaGVja2VkLFxyXG4gICAgICAgICAgICAgICAgZHJhd0F2ZzogZ2V0RWwoJ3Nob3dBdmdEYXRhJykuY2hlY2tlZCxcclxuICAgICAgICAgICAgICAgIGRyYXdNZWRpYW46IGdldEVsKCdzaG93TWVkaWFuRGF0YScpLmNoZWNrZWQsXHJcbiAgICAgICAgICAgICAgICBkcmF3WUxvZzogZ2V0RWwoJ3Nob3dZTG9nRGF0YScpLmNoZWNrZWQsXHJcbiAgICAgICAgICAgICAgICBkcmF3WExvZzogZ2V0RWwoJ3Nob3dYTG9nRGF0YScpLmNoZWNrZWQsXHJcbiAgICAgICAgICAgICAgICBtYXhYOiBnZXRFbCgnbWF4WEVuYWJsZWQnKS5jaGVja2VkID8gTnVtYmVyKGdldEVsKCdtYXhYJykudmFsdWUpIDogbnVsbCxcclxuICAgICAgICAgICAgICAgIG1pblg6IGdldEVsKCdtaW5YRW5hYmxlZCcpLmNoZWNrZWQgPyBOdW1iZXIoZ2V0RWwoJ21pblgnKS52YWx1ZSkgOiBudWxsLFxyXG4gICAgICAgICAgICAgICAgbWF4WTogZ2V0RWwoJ21heFlFbmFibGVkJykuY2hlY2tlZCA/IE51bWJlcihnZXRFbCgnbWF4WScpLnZhbHVlKSA6IG51bGwsXHJcbiAgICAgICAgICAgICAgICBtaW5ZOiBnZXRFbCgnbWluWUVuYWJsZWQnKS5jaGVja2VkID8gTnVtYmVyKGdldEVsKCdtaW5ZJykudmFsdWUpIDogbnVsbCxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZHJhd0NoYXJ0KGRhdGFiYXNlLCBtZWFzdXJlZFBhcmFtc0xpc3QsIG9wdHMpIHtcclxuICAgICAgICBjb25zdCBjaGFuZ2VkUGFyYW0gPSBkYXRhYmFzZS5jaGFuZ2VkUGFyYW1zWzBdO1xyXG4gICAgICAgIGxldCBkYXRhID0gW107XHJcbiAgICAgICAgY29uc3QgeFNjYWxlciA9IG9wdHMuZHJhd1hMb2cgPyBNYXRoLmxvZyA6IFIuaWRlbnRpdHk7XHJcbi8vICAgICAgICBjb25zdCB4U2NhbGVyID0gUi5pZGVudGl0eTtcclxuICAgICAgICBjb25zdCB5U2NhbGVyID0gb3B0cy5kcmF3WUxvZyA/IE1hdGgubG9nIDogUi5pZGVudGl0eTtcclxuXHJcbiAgICAgICAgY29uc3QgbWVhc3VyZWRQYXJhbXMgPSBSLmZpbHRlcihSLmNvbXBvc2UoUi5jb250YWlucyhSLl9fLCBtZWFzdXJlZFBhcmFtc0xpc3QpLCBSLnByb3AoJ25hbWUnKSksIGRhdGFiYXNlLm1lYXN1cmVkUGFyYW1zKTtcclxuXHJcbiAgICAgICAgaWYgKG9wdHMuZHJhd1Jhdykge1xyXG4gICAgICAgICAgICBjb25zdCByYXdEYXRhID0gUi5mbGF0dGVuKG1lYXN1cmVkUGFyYW1zLm1hcChtYWtlUmF3RGF0YUxpbmVzKHhTY2FsZXIsIHlTY2FsZXIsIGRhdGFiYXNlLCBjaGFuZ2VkUGFyYW0pKSk7XHJcbiAgICAgICAgICAgIGRhdGEgPSBkYXRhLmNvbmNhdChyYXdEYXRhKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChvcHRzLmRyYXdBdmcpIHtcclxuICAgICAgICAgICAgY29uc3QgYXZnRGF0YSA9IFIuZmxhdHRlbihtZWFzdXJlZFBhcmFtcy5tYXAobWFrZUF2Z0RhdGFMaW5lcyh4U2NhbGVyLCB5U2NhbGVyLCBkYXRhYmFzZSwgY2hhbmdlZFBhcmFtKSkpO1xyXG4gICAgICAgICAgICBkYXRhID0gZGF0YS5jb25jYXQoYXZnRGF0YSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAob3B0cy5kcmF3TWVkaWFuKSB7XHJcbiAgICAgICAgICAgIGRhdGEgPSBkYXRhLmNvbmNhdChSLmZsYXR0ZW4obWVhc3VyZWRQYXJhbXMubWFwKG1ha2VNZWRpYW5EYXRhTGluZXMoeFNjYWxlciwgeVNjYWxlciwgZGF0YWJhc2UsIGNoYW5nZWRQYXJhbSkpKSk7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgY29uc3QgY2hhcnQgPSBuZXcgQ2FudmFzSlMuQ2hhcnQoJ2NoYXJ0Q29udGFpbmVyJywge1xyXG4gICAgICAgICAgICB6b29tRW5hYmxlZDogdHJ1ZSwgXHJcbiAgICAgICAgICAgIHpvb21UeXBlOiBcInh5XCIsXHJcbiAgICAgICAgICAgIGV4cG9ydEVuYWJsZWQ6IHRydWUsXHJcbi8vICAgICAgICAgICAgaW50ZXJhY3Rpdml0eUVuYWJsZWQ6IHRydWUsXHJcbiAgICAgICAgICAgIGF4aXNYOiB7XHJcbiAgICAgICAgICAgICAgICB0aXRsZTogcGFyYW1UaXRsZShjaGFuZ2VkUGFyYW0pLFxyXG4gICAgICAgICAgICAgICAgdGl0bGVGb250U2l6ZTogMTgsXHJcbiAgICAgICAgICAgICAgICBtaW5pbXVtOiBvcHRzLm1pblgsXHJcbiAgICAgICAgICAgICAgICBtYXhpbXVtOiBvcHRzLm1heFgsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGF4aXNZOiB7XHJcbiAgICAgICAgICAgICAgICB0aXRsZTogcGFyYW1UaXRsZShkYXRhYmFzZS5tZWFzdXJlZFBhcmFtc1swXSksXHJcbiAgICAgICAgICAgICAgICB0aXRsZUZvbnRTaXplOiAxNixcclxuICAgICAgICAgICAgICAgIG1pbmltdW06IG9wdHMubWluWSxcclxuICAgICAgICAgICAgICAgIG1heGltdW06IG9wdHMubWF4WSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgbGVnZW5kOiB7XHJcbiAgICAgICAgICAgICAgICB2ZXJ0aWNhbEFsaWduOiAnYm90dG9tJyxcclxuICAgICAgICAgICAgICAgIGhvcml6b250YWxBbGlnbjogJ2NlbnRlcidcclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIGRhdGFcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgY2hhcnQucmVuZGVyKCk7XHJcblxyXG4gICAgICAgIGZpbGxEYXRhVGFibGUoZGF0YSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZmlsbERhdGFUYWJsZShkYXRhKSB7XHJcbiAgICAgICAgY29uc3QgdGhlYWQgPSBjbGVhckVsKHF1ZXJ5RWwoYCR7cm9vdH0udGFibGUtcGFuZWwgdGFibGUgdGhlYWRgKSk7XHJcbiAgICAgICAgY29uc3QgdGJvZHkgPSBjbGVhckVsKHF1ZXJ5RWwoYCR7cm9vdH0udGFibGUtcGFuZWwgdGFibGUgdGJvZHlgKSk7XHJcblxyXG4gICAgICAgIGNvbnN0IGRhdGEyID0gW107XHJcblxyXG4gICAgICAgIGNvbnN0IGtleXMgPSBbJ3RyYWNrIG5hbWUnLCAndW5pdHMnXS5jb25jYXQoZGF0YVswXS5kYXRhUG9pbnRzLm1hcChSLnByb3AoJ3gnKSkpO1xyXG4gICAgICAgIGRhdGEyLnB1c2goa2V5cyk7XHJcbiAgICAgICAgYWRkRWwodGhlYWQsIGFkZEVscyhtYWtlRWwoJ3RyJyksIGtleXMubWFwKG1ha2VUZXh0KS5tYXAoZWwgPT4gYWRkRWwobWFrZUVsKCd0aCcpLCBlbCkpKSk7XHJcblxyXG4gICAgICAgIGFkZEVscyh0Ym9keSwgZGF0YS5tYXAoKHJvdykgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB2YWxzID0gW3Jvdy5sZWdlbmRUZXh0LCByb3cudW5pdHNdLmNvbmNhdChyb3cuZGF0YVBvaW50cy5tYXAoUi5wcm9wKCd5JykpKTtcclxuICAgICAgICAgICAgZGF0YTIucHVzaCh2YWxzKTtcclxuICAgICAgICAgICAgcmV0dXJuIGFkZEVscyhtYWtlRWwoJ3RyJyksIHZhbHMubWFwKG1ha2VUZXh0KS5tYXAoZWwgPT4gYWRkRWwobWFrZUVsKCd0ZCcpLCBlbCkpKTtcclxuICAgICAgICB9KSk7XHJcbiAgICAgICAgc3RhdGUuZGF0YSA9IGRhdGEyO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdmFyLHZhcnMtb24tdG9wXHJcbiAgICB2YXIgbWFrZVJhd0RhdGFMaW5lcyA9IFIuY3VycnkoKHhTY2FsZXIsIHlTY2FsZXIsIGRhdGFiYXNlLCBjaGFuZ2VkUGFyYW0sIG1lYXN1cmVkUGFyYW0pID0+IHtcclxuICAgICAgICBjb25zdCBwYXNzZXMgPSBSLmdyb3VwQnkoaXRlbSA9PiBpdGVtLnBhc3NJZCwgUi52YWx1ZXMoZGF0YWJhc2UubWVhc3VyZXMpKTtcclxuXHJcbiAgICAgICAgY29uc3QgZGF0YVBvaW50cyA9IFIubWFwKHBhc3NBcnJheSA9PiBwYXNzQXJyYXkubWFwKGl0ZW0gPT4gKHtcclxuICAgICAgICAgICAgeDogeFNjYWxlcihpdGVtW2NoYW5nZWRQYXJhbS5uYW1lXSksXHJcbiAgICAgICAgICAgIHk6IHlTY2FsZXIoaXRlbVttZWFzdXJlZFBhcmFtLm5hbWVdKSxcclxuICAgICAgICAgICAgdG9vbFRpcENvbnRlbnQ6IEwxMG4uZm9ybWF0KFxyXG4gICAgICAgICAgICAgICAgJ3BlcmZvcm1hbmNlJywgJ3Rvb2x0aXAtc2NoZW1hJyxcclxuICAgICAgICAgICAgICAgIFtcclxuICAgICAgICAgICAgICAgICAgICBtZWFzdXJlZFBhcmFtLm5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5wYXNzSWQsXHJcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1UaXRsZShjaGFuZ2VkUGFyYW0pLFxyXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1bY2hhbmdlZFBhcmFtLm5hbWVdLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtVGl0bGUobWVhc3VyZWRQYXJhbSksXHJcbiAgICAgICAgICAgICAgICAgICAgaXRlbVttZWFzdXJlZFBhcmFtLm5hbWVdXHJcbiAgICAgICAgICAgICAgICBdXHJcbiAgICAgICAgICAgIClcclxuICAgICAgICB9KSksIHBhc3Nlcyk7XHJcblxyXG4gICAgICAgIHJldHVybiBSLnZhbHVlcyhSLm1hcE9iakluZGV4ZWQoKGFycmF5LCBrZXkpID0+ICh7XHJcbiAgICAgICAgICAgIHNob3dJbkxlZ2VuZDogdHJ1ZSxcclxuICAgICAgICAgICAgbGVnZW5kVGV4dDogYCR7bWVhc3VyZWRQYXJhbS5uYW1lfSAke2tleX1gLFxyXG4gICAgICAgICAgICB0eXBlOiAnbGluZScsXHJcbiAgICAgICAgICAgIG1hcmtlclR5cGU6ICdjaXJjbGUnLFxyXG4gICAgICAgICAgICBtYXJrZXJCb3JkZXJDb2xvcjogJ2JsYWNrJyxcclxuICAgICAgICAgICAgbWFya2VyU2l6ZTogMTUsXHJcbiAgICAgICAgICAgIG1hcmtlckJvcmRlclRoaWNrbmVzczogMSxcclxuICAgICAgICAgICAgdW5pdHM6IG1lYXN1cmVkUGFyYW0udW5pdHMsXHJcbiAgICAgICAgICAgIGRhdGFQb2ludHM6IGFycmF5XHJcbiAgICAgICAgfSksIGRhdGFQb2ludHMpKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IG1ha2VBZ2dyZWdhdGVkRGF0YUxpbmVzID1cclxuICAgICAgICBSLmN1cnJ5KChsYWJlbCwgYWdncmVnYXRpb25GdW5jdGlvbiwgeFNjYWxlciwgeVNjYWxlciwgZGF0YWJhc2UsIGNoYW5nZWRQYXJhbSwgbWVhc3VyZWRQYXJhbSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBwb2ludGVkID0gUi5ncm91cEJ5KGl0ZW0gPT4gaXRlbVtjaGFuZ2VkUGFyYW0ubmFtZV0sIFIudmFsdWVzKGRhdGFiYXNlLm1lYXN1cmVzKSk7XHJcblxyXG4gICAgICAgICAgICBsZXQgYXZnID0gUi5tYXAoKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBjbG9uZSA9IFIuY2xvbmUodmFsdWVbMF0pO1xyXG4gICAgICAgICAgICAgICAgY29uc3QgcmF3VmFsdWVzID0gUi5hcChbUi5wcm9wKG1lYXN1cmVkUGFyYW0ubmFtZSldLCB2YWx1ZSkuc29ydCgpO1xyXG4gICAgICAgICAgICAgICAgY2xvbmVbbWVhc3VyZWRQYXJhbS5uYW1lXSA9IHlTY2FsZXIoYWdncmVnYXRpb25GdW5jdGlvbihyYXdWYWx1ZXMpKTtcclxuICAgICAgICAgICAgICAgIGNsb25lLnlEaXNwbGF5TmFtZSA9IGFnZ3JlZ2F0aW9uRnVuY3Rpb24ocmF3VmFsdWVzKTtcclxuICAgICAgICAgICAgICAgIGNsb25lW2NoYW5nZWRQYXJhbS5uYW1lXSA9IHhTY2FsZXIodmFsdWVbMF1bY2hhbmdlZFBhcmFtLm5hbWVdKTtcclxuICAgICAgICAgICAgICAgIGNsb25lLnhEaXNwbGF5TmFtZSA9IHZhbHVlWzBdW2NoYW5nZWRQYXJhbS5uYW1lXTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjbG9uZTtcclxuICAgICAgICAgICAgfSwgcG9pbnRlZCk7XHJcblxyXG4gICAgICAgICAgICBhdmcgPSBSLnZhbHVlcyhhdmcpLm1hcChpdGVtID0+ICh7XHJcbiAgICAgICAgICAgICAgICB4OiBpdGVtW2NoYW5nZWRQYXJhbS5uYW1lXSxcclxuICAgICAgICAgICAgICAgIHk6IGl0ZW1bbWVhc3VyZWRQYXJhbS5uYW1lXSxcclxuICAgICAgICAgICAgICAgIHRvb2xUaXBDb250ZW50OiBzdHJGb3JtYXQoXHJcbiAgICAgICAgICAgICAgICAgICAgJ3swfTogezF9PGJyLz57Mn06IHszfScsXHJcbiAgICAgICAgICAgICAgICAgICAgW3BhcmFtVGl0bGUoY2hhbmdlZFBhcmFtKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbVtjaGFuZ2VkUGFyYW0ubmFtZV0gKyAnIChyYXcgdmFsdWUgJyArIGl0ZW0ueERpc3BsYXlOYW1lICsgJyknLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbVRpdGxlKG1lYXN1cmVkUGFyYW0pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtW21lYXN1cmVkUGFyYW0ubmFtZV0gKyAnIChyYXcgdmFsdWUgJyArIGl0ZW0ueURpc3BsYXlOYW1lICsgJyknXVxyXG4gICAgICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICB9KSk7XHJcblxyXG4gICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgc2hvd0luTGVnZW5kOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgbGVnZW5kVGV4dDogYCR7bWVhc3VyZWRQYXJhbS5uYW1lfSAke2xhYmVsfWAsXHJcbiAgICAgICAgICAgICAgICB0eXBlOiAnbGluZScsXHJcbiAgICAgICAgICAgICAgICBtYXJrZXJUeXBlOiAnY2lyY2xlJyxcclxuICAgICAgICAgICAgICAgIG1hcmtlckJvcmRlckNvbG9yOiAnYmxhY2snLFxyXG4gICAgICAgICAgICAgICAgbWFya2VyU2l6ZTogMzAsXHJcbiAgICAgICAgICAgICAgICBtYXJrZXJCb3JkZXJUaGlja25lc3M6IDEsXHJcbiAgICAgICAgICAgICAgICB1bml0czogbWVhc3VyZWRQYXJhbS51bml0cyxcclxuICAgICAgICAgICAgICAgIGRhdGFQb2ludHM6IGF2Z1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby12YXIsdmFycy1vbi10b3BcclxuICAgIHZhciBtYWtlTWVkaWFuRGF0YUxpbmVzID0gbWFrZUFnZ3JlZ2F0ZWREYXRhTGluZXMoJ21lZGlhbicsIFIubWVkaWFuKTtcclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby12YXIsdmFycy1vbi10b3BcclxuICAgIHZhciBtYWtlQXZnRGF0YUxpbmVzID0gbWFrZUFnZ3JlZ2F0ZWREYXRhTGluZXMoJ2F2ZycsIFIubWVhbik7XHJcbn0pKHRoaXMuUGVyZm9ybWFuY2UgPSB7fSk7XHJcbiIsIi8qQ29weXJpZ2h0IDIwMTcgVGltb2ZleSBSZWNoa2Fsb3YgPG50c2RrQHlhbmRleC5ydT5cclxuXHJcbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcblxyXG5odHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gICAgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG4oKGV4cG9ydHMpID0+IHtcclxuICAgIGNvbnN0IHJvb3QgPSAnLi10YWIgJztcclxuICAgIGNvbnN0IHN0YXRlID0ge307XHJcblxyXG4gICAgZXhwb3J0cy5pbml0ID0gKCkgPT4ge1xyXG4gICAgICAgIGV4cG9ydHMuY29udGVudCA9IHF1ZXJ5RWwocm9vdCk7XHJcbiAgICB9O1xyXG5cclxuICAgIGV4cG9ydHMucmVmcmVzaCA9ICgpID0+IHtcclxuXHJcbiAgICB9O1xyXG59KSh0aGlzLlRlbXBsYXRlID0ge30pO1xyXG4iLCIvKkNvcHlyaWdodCAyMDE3IFRpbW9mZXkgUmVjaGthbG92IDxudHNka0B5YW5kZXgucnU+XHJcblxyXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xyXG55b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXHJcbllvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxyXG5cclxuaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG5Vbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXHJcbmRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcclxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXHJcblNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcclxuICAgIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLiAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnO1xyXG5cclxuKChleHBvcnRzKSA9PiB7XHJcbiAgICBleHBvcnRzLmluaXQgPSAoKSA9PiB7XHJcbiAgICAgICAgZXhwb3J0cy5jb250ZW50ID0gZ2V0RWwoJ2Fib3V0RGl2Jyk7XHJcbiAgICB9O1xyXG5cclxuICAgIGV4cG9ydHMucmVmcmVzaCA9ICgpID0+IHtcclxuICAgIH07XHJcbn0pKHRoaXMuQWJvdXQgPSB7fSk7XHJcbiJdLCJzb3VyY2VSb290IjoiL3NvdXJjZS8ifQ==

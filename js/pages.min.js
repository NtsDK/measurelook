/*Copyright 2017 Timofey Rechkalov <ntsdk@yandex.ru>

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
    limitations under the License. */

'use strict';

((exports) => {
    const l10n = L10n.get('performance');
    const root = '.performance-tab ';
    const state = {};

    exports.init = () => {
        listen(getEl('chartDataSelector'), 'change', onSettingsChange);
        listen(getEl('showRawData'), 'change', onSettingsChange);
        listen(getEl('showAvgData'), 'change', onSettingsChange);
        listen(getEl('showMedianData'), 'change', onSettingsChange);
        listen(getEl('showYLogData'), 'change', onSettingsChange);
        getEl('showRawData').checked = true;
        getEl('showAvgData').checked = false;
        getEl('showMedianData').checked = false;
        getEl('showYLogData').checked = false;
        listen(queryEl(`${root}.download-csv-button`), 'click', () => FileUtils.arr2d2Csv(state.data, 'table.csv'));

        exports.content = queryEl(root);
    };

    function paramTitle(param) {
        return `${param.name}, ${param.units}`;
    }

    const makeRow = R.curry((title, getName, getValue, key, i, arr) => {
        let els = [addEl(makeEl('td'), makeText(getName(key))), addEl(makeEl('td'), makeText(getValue(key)))];
        if (i === 0) {
            const el = addEl(makeEl('th'), makeText(title));
            setAttr(el, 'rowspan', arr.length);
            els = [el].concat(els);
        }
        return addEls(makeEl('tr'), els);
    });

    exports.refresh = () => {
        const table = clearEl(queryEl('#benchmark-description tbody'));

        DBMS.getDatabase((err, database) => {
            if (err) { Utils.handleError(err); return; }

            addEls(
                table,
                Object.keys(database.meta)
                    .sort()
                    .map(makeRow(
                        l10n('metainformation'), key => key,
                        key => database.meta[key]
                    ))
            );
            addEls(table, database.constantParams.map(makeRow(l10n('constants'), item => paramTitle(item), item => item.value)));
            addEls(table, database.changedParams.map(makeRow(l10n('changed-params'), item => paramTitle(item), item => '')));
            addEls(table, database.measuredParams.map(makeRow(l10n('measured-params'), item => paramTitle(item), item => '')));

            fillSelector(clearEl(getEl('chartDataSelector')), database.measuredParams.map(val => ({
                name: val.name,
                value: val.name,
                selected: true
            })));
            setAttr(getEl('chartDataSelector'), 'size', database.measuredParams.length);

            onSettingsChange();
        });
    };

    function onSettingsChange() {
        const measuredParamsList = nl2array(getEl('chartDataSelector').selectedOptions).map(R.prop('value'));

        DBMS.getDatabase((err, database) => {
            drawChart(database, measuredParamsList, {
                drawRaw: getEl('showRawData').checked,
                drawAvg: getEl('showAvgData').checked,
                drawMedian: getEl('showMedianData').checked,
                drawYLog: getEl('showYLogData').checked
            });
        });
    }

    function drawChart(database, measuredParamsList, opts) {
        const changedParam = database.changedParams[0];
        let data = [];
        const scaler = opts.drawYLog ? Math.log : R.identity;

        const measuredParams = R.filter(R.compose(R.contains(R.__, measuredParamsList), R.prop('name')), database.measuredParams);

        if (opts.drawRaw) {
            const rawData = R.flatten(measuredParams.map(makeRawDataLines(scaler, database, changedParam)));
            data = data.concat(rawData);
        }

        if (opts.drawAvg) {
            const avgData = R.flatten(measuredParams.map(makeAvgDataLines(scaler, database, changedParam)));
            data = data.concat(avgData);
        }

        if (opts.drawMedian) {
            data = data.concat(R.flatten(measuredParams.map(makeMedianDataLines(scaler, database, changedParam))));
        }


        const chart = new CanvasJS.Chart('chartContainer', {
            axisX: {
                title: paramTitle(changedParam),
                titleFontSize: 18
            },
            axisY: {
                title: paramTitle(database.measuredParams[0]),
                titleFontSize: 16
            },
            legend: {
                verticalAlign: 'bottom',
                horizontalAlign: 'center'
            },

            data
        });

        chart.render();

        fillDataTable(data);
    }

    function fillDataTable(data) {
        const thead = clearEl(queryEl(`${root}.table-panel table thead`));
        const tbody = clearEl(queryEl(`${root}.table-panel table tbody`));

        const data2 = [];

        const keys = ['track name', 'units'].concat(data[0].dataPoints.map(R.prop('x')));
        data2.push(keys);
        addEl(thead, addEls(makeEl('tr'), keys.map(makeText).map(el => addEl(makeEl('th'), el))));

        addEls(tbody, data.map((row) => {
            const vals = [row.legendText, row.units].concat(row.dataPoints.map(R.prop('y')));
            data2.push(vals);
            return addEls(makeEl('tr'), vals.map(makeText).map(el => addEl(makeEl('td'), el)));
        }));
        state.data = data2;
    }


    // eslint-disable-next-line no-var,vars-on-top
    var makeRawDataLines = R.curry((scaler, database, changedParam, measuredParam) => {
        const passes = R.groupBy(item => item.passId, R.values(database.measures));

        const dataPoints = R.map(passArray => passArray.map(item => ({
            x: item[changedParam.name],
            y: scaler(item[measuredParam.name]),
            toolTipContent: L10n.format(
                'performance', 'tooltip-schema',
                [
                    measuredParam.name,
                    item.passId,
                    paramTitle(changedParam),
                    item[changedParam.name],
                    paramTitle(measuredParam),
                    item[measuredParam.name]
                ]
            )
        })), passes);

        return R.values(R.mapObjIndexed((array, key) => ({
            showInLegend: true,
            legendText: `${measuredParam.name} ${key}`,
            type: 'line',
            markerType: 'circle',
            markerBorderColor: 'black',
            markerSize: 15,
            markerBorderThickness: 1,
            units: measuredParam.units,
            dataPoints: array
        }), dataPoints));
    });

    const makeAggregatedDataLines =
        R.curry((label, aggregationFunction, scaler, database, changedParam, measuredParam) => {
            const pointed = R.groupBy(item => item[changedParam.name], R.values(database.measures));

            let avg = R.map((value) => {
                const clone = R.clone(value[0]);
                const rawValues = R.ap([R.prop(measuredParam.name)], value).sort();
                clone[measuredParam.name] = scaler(aggregationFunction(rawValues));
                return clone;
            }, pointed);

            avg = R.values(avg).map(item => ({
                x: item[changedParam.name],
                y: item[measuredParam.name],
                toolTipContent: strFormat(
                    '{0}: {1}<br/>{2}: {3}',
                    [paramTitle(changedParam),
                        item[changedParam.name],
                        paramTitle(measuredParam),
                        item[measuredParam.name]]
                )
            }));

            return {
                showInLegend: true,
                legendText: `${measuredParam.name} ${label}`,
                type: 'line',
                markerType: 'circle',
                markerBorderColor: 'black',
                markerSize: 30,
                markerBorderThickness: 1,
                units: measuredParam.units,
                dataPoints: avg
            };
        });

    // eslint-disable-next-line no-var,vars-on-top
    var makeMedianDataLines = makeAggregatedDataLines('median', R.median);
    // eslint-disable-next-line no-var,vars-on-top
    var makeAvgDataLines = makeAggregatedDataLines('avg', R.mean);
})(this.Performance = {});

/*Copyright 2017 Timofey Rechkalov <ntsdk@yandex.ru>

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
    limitations under the License. */

'use strict';

((exports) => {
    const root = '.-tab ';
    const state = {};

    exports.init = () => {
        exports.content = queryEl(root);
    };

    exports.refresh = () => {

    };
})(this.Template = {});

/*Copyright 2017 Timofey Rechkalov <ntsdk@yandex.ru>

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
    limitations under the License. */

'use strict';

((exports) => {
    exports.init = () => {
        exports.content = getEl('aboutDiv');
    };

    exports.refresh = () => {
    };
})(this.About = {});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImpzL3BhZ2VzL3BlcmZvcm1hbmNlLmpzIiwianMvcGFnZXMvdGVtcGxhdGUuanMiLCJqcy9wYWdlcy9sb2dzL2Fib3V0LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3RPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6InBhZ2VzLm1pbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qQ29weXJpZ2h0IDIwMTcgVGltb2ZleSBSZWNoa2Fsb3YgPG50c2RrQHlhbmRleC5ydT5cclxuXHJcbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcblxyXG5odHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gICAgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG4oKGV4cG9ydHMpID0+IHtcclxuICAgIGNvbnN0IGwxMG4gPSBMMTBuLmdldCgncGVyZm9ybWFuY2UnKTtcclxuICAgIGNvbnN0IHJvb3QgPSAnLnBlcmZvcm1hbmNlLXRhYiAnO1xyXG4gICAgY29uc3Qgc3RhdGUgPSB7fTtcclxuXHJcbiAgICBleHBvcnRzLmluaXQgPSAoKSA9PiB7XHJcbiAgICAgICAgbGlzdGVuKGdldEVsKCdjaGFydERhdGFTZWxlY3RvcicpLCAnY2hhbmdlJywgb25TZXR0aW5nc0NoYW5nZSk7XHJcbiAgICAgICAgbGlzdGVuKGdldEVsKCdzaG93UmF3RGF0YScpLCAnY2hhbmdlJywgb25TZXR0aW5nc0NoYW5nZSk7XHJcbiAgICAgICAgbGlzdGVuKGdldEVsKCdzaG93QXZnRGF0YScpLCAnY2hhbmdlJywgb25TZXR0aW5nc0NoYW5nZSk7XHJcbiAgICAgICAgbGlzdGVuKGdldEVsKCdzaG93TWVkaWFuRGF0YScpLCAnY2hhbmdlJywgb25TZXR0aW5nc0NoYW5nZSk7XHJcbiAgICAgICAgbGlzdGVuKGdldEVsKCdzaG93WUxvZ0RhdGEnKSwgJ2NoYW5nZScsIG9uU2V0dGluZ3NDaGFuZ2UpO1xyXG4gICAgICAgIGdldEVsKCdzaG93UmF3RGF0YScpLmNoZWNrZWQgPSB0cnVlO1xyXG4gICAgICAgIGdldEVsKCdzaG93QXZnRGF0YScpLmNoZWNrZWQgPSBmYWxzZTtcclxuICAgICAgICBnZXRFbCgnc2hvd01lZGlhbkRhdGEnKS5jaGVja2VkID0gZmFsc2U7XHJcbiAgICAgICAgZ2V0RWwoJ3Nob3dZTG9nRGF0YScpLmNoZWNrZWQgPSBmYWxzZTtcclxuICAgICAgICBsaXN0ZW4ocXVlcnlFbChgJHtyb290fS5kb3dubG9hZC1jc3YtYnV0dG9uYCksICdjbGljaycsICgpID0+IEZpbGVVdGlscy5hcnIyZDJDc3Yoc3RhdGUuZGF0YSwgJ3RhYmxlLmNzdicpKTtcclxuXHJcbiAgICAgICAgZXhwb3J0cy5jb250ZW50ID0gcXVlcnlFbChyb290KTtcclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gcGFyYW1UaXRsZShwYXJhbSkge1xyXG4gICAgICAgIHJldHVybiBgJHtwYXJhbS5uYW1lfSwgJHtwYXJhbS51bml0c31gO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IG1ha2VSb3cgPSBSLmN1cnJ5KCh0aXRsZSwgZ2V0TmFtZSwgZ2V0VmFsdWUsIGtleSwgaSwgYXJyKSA9PiB7XHJcbiAgICAgICAgbGV0IGVscyA9IFthZGRFbChtYWtlRWwoJ3RkJyksIG1ha2VUZXh0KGdldE5hbWUoa2V5KSkpLCBhZGRFbChtYWtlRWwoJ3RkJyksIG1ha2VUZXh0KGdldFZhbHVlKGtleSkpKV07XHJcbiAgICAgICAgaWYgKGkgPT09IDApIHtcclxuICAgICAgICAgICAgY29uc3QgZWwgPSBhZGRFbChtYWtlRWwoJ3RoJyksIG1ha2VUZXh0KHRpdGxlKSk7XHJcbiAgICAgICAgICAgIHNldEF0dHIoZWwsICdyb3dzcGFuJywgYXJyLmxlbmd0aCk7XHJcbiAgICAgICAgICAgIGVscyA9IFtlbF0uY29uY2F0KGVscyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBhZGRFbHMobWFrZUVsKCd0cicpLCBlbHMpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgZXhwb3J0cy5yZWZyZXNoID0gKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IHRhYmxlID0gY2xlYXJFbChxdWVyeUVsKCcjYmVuY2htYXJrLWRlc2NyaXB0aW9uIHRib2R5JykpO1xyXG5cclxuICAgICAgICBEQk1TLmdldERhdGFiYXNlKChlcnIsIGRhdGFiYXNlKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChlcnIpIHsgVXRpbHMuaGFuZGxlRXJyb3IoZXJyKTsgcmV0dXJuOyB9XHJcblxyXG4gICAgICAgICAgICBhZGRFbHMoXHJcbiAgICAgICAgICAgICAgICB0YWJsZSxcclxuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGRhdGFiYXNlLm1ldGEpXHJcbiAgICAgICAgICAgICAgICAgICAgLnNvcnQoKVxyXG4gICAgICAgICAgICAgICAgICAgIC5tYXAobWFrZVJvdyhcclxuICAgICAgICAgICAgICAgICAgICAgICAgbDEwbignbWV0YWluZm9ybWF0aW9uJyksIGtleSA9PiBrZXksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9PiBkYXRhYmFzZS5tZXRhW2tleV1cclxuICAgICAgICAgICAgICAgICAgICApKVxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgICBhZGRFbHModGFibGUsIGRhdGFiYXNlLmNvbnN0YW50UGFyYW1zLm1hcChtYWtlUm93KGwxMG4oJ2NvbnN0YW50cycpLCBpdGVtID0+IHBhcmFtVGl0bGUoaXRlbSksIGl0ZW0gPT4gaXRlbS52YWx1ZSkpKTtcclxuICAgICAgICAgICAgYWRkRWxzKHRhYmxlLCBkYXRhYmFzZS5jaGFuZ2VkUGFyYW1zLm1hcChtYWtlUm93KGwxMG4oJ2NoYW5nZWQtcGFyYW1zJyksIGl0ZW0gPT4gcGFyYW1UaXRsZShpdGVtKSwgaXRlbSA9PiAnJykpKTtcclxuICAgICAgICAgICAgYWRkRWxzKHRhYmxlLCBkYXRhYmFzZS5tZWFzdXJlZFBhcmFtcy5tYXAobWFrZVJvdyhsMTBuKCdtZWFzdXJlZC1wYXJhbXMnKSwgaXRlbSA9PiBwYXJhbVRpdGxlKGl0ZW0pLCBpdGVtID0+ICcnKSkpO1xyXG5cclxuICAgICAgICAgICAgZmlsbFNlbGVjdG9yKGNsZWFyRWwoZ2V0RWwoJ2NoYXJ0RGF0YVNlbGVjdG9yJykpLCBkYXRhYmFzZS5tZWFzdXJlZFBhcmFtcy5tYXAodmFsID0+ICh7XHJcbiAgICAgICAgICAgICAgICBuYW1lOiB2YWwubmFtZSxcclxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWwubmFtZSxcclxuICAgICAgICAgICAgICAgIHNlbGVjdGVkOiB0cnVlXHJcbiAgICAgICAgICAgIH0pKSk7XHJcbiAgICAgICAgICAgIHNldEF0dHIoZ2V0RWwoJ2NoYXJ0RGF0YVNlbGVjdG9yJyksICdzaXplJywgZGF0YWJhc2UubWVhc3VyZWRQYXJhbXMubGVuZ3RoKTtcclxuXHJcbiAgICAgICAgICAgIG9uU2V0dGluZ3NDaGFuZ2UoKTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gb25TZXR0aW5nc0NoYW5nZSgpIHtcclxuICAgICAgICBjb25zdCBtZWFzdXJlZFBhcmFtc0xpc3QgPSBubDJhcnJheShnZXRFbCgnY2hhcnREYXRhU2VsZWN0b3InKS5zZWxlY3RlZE9wdGlvbnMpLm1hcChSLnByb3AoJ3ZhbHVlJykpO1xyXG5cclxuICAgICAgICBEQk1TLmdldERhdGFiYXNlKChlcnIsIGRhdGFiYXNlKSA9PiB7XHJcbiAgICAgICAgICAgIGRyYXdDaGFydChkYXRhYmFzZSwgbWVhc3VyZWRQYXJhbXNMaXN0LCB7XHJcbiAgICAgICAgICAgICAgICBkcmF3UmF3OiBnZXRFbCgnc2hvd1Jhd0RhdGEnKS5jaGVja2VkLFxyXG4gICAgICAgICAgICAgICAgZHJhd0F2ZzogZ2V0RWwoJ3Nob3dBdmdEYXRhJykuY2hlY2tlZCxcclxuICAgICAgICAgICAgICAgIGRyYXdNZWRpYW46IGdldEVsKCdzaG93TWVkaWFuRGF0YScpLmNoZWNrZWQsXHJcbiAgICAgICAgICAgICAgICBkcmF3WUxvZzogZ2V0RWwoJ3Nob3dZTG9nRGF0YScpLmNoZWNrZWRcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gZHJhd0NoYXJ0KGRhdGFiYXNlLCBtZWFzdXJlZFBhcmFtc0xpc3QsIG9wdHMpIHtcclxuICAgICAgICBjb25zdCBjaGFuZ2VkUGFyYW0gPSBkYXRhYmFzZS5jaGFuZ2VkUGFyYW1zWzBdO1xyXG4gICAgICAgIGxldCBkYXRhID0gW107XHJcbiAgICAgICAgY29uc3Qgc2NhbGVyID0gb3B0cy5kcmF3WUxvZyA/IE1hdGgubG9nIDogUi5pZGVudGl0eTtcclxuXHJcbiAgICAgICAgY29uc3QgbWVhc3VyZWRQYXJhbXMgPSBSLmZpbHRlcihSLmNvbXBvc2UoUi5jb250YWlucyhSLl9fLCBtZWFzdXJlZFBhcmFtc0xpc3QpLCBSLnByb3AoJ25hbWUnKSksIGRhdGFiYXNlLm1lYXN1cmVkUGFyYW1zKTtcclxuXHJcbiAgICAgICAgaWYgKG9wdHMuZHJhd1Jhdykge1xyXG4gICAgICAgICAgICBjb25zdCByYXdEYXRhID0gUi5mbGF0dGVuKG1lYXN1cmVkUGFyYW1zLm1hcChtYWtlUmF3RGF0YUxpbmVzKHNjYWxlciwgZGF0YWJhc2UsIGNoYW5nZWRQYXJhbSkpKTtcclxuICAgICAgICAgICAgZGF0YSA9IGRhdGEuY29uY2F0KHJhd0RhdGEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG9wdHMuZHJhd0F2Zykge1xyXG4gICAgICAgICAgICBjb25zdCBhdmdEYXRhID0gUi5mbGF0dGVuKG1lYXN1cmVkUGFyYW1zLm1hcChtYWtlQXZnRGF0YUxpbmVzKHNjYWxlciwgZGF0YWJhc2UsIGNoYW5nZWRQYXJhbSkpKTtcclxuICAgICAgICAgICAgZGF0YSA9IGRhdGEuY29uY2F0KGF2Z0RhdGEpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKG9wdHMuZHJhd01lZGlhbikge1xyXG4gICAgICAgICAgICBkYXRhID0gZGF0YS5jb25jYXQoUi5mbGF0dGVuKG1lYXN1cmVkUGFyYW1zLm1hcChtYWtlTWVkaWFuRGF0YUxpbmVzKHNjYWxlciwgZGF0YWJhc2UsIGNoYW5nZWRQYXJhbSkpKSk7XHJcbiAgICAgICAgfVxyXG5cclxuXHJcbiAgICAgICAgY29uc3QgY2hhcnQgPSBuZXcgQ2FudmFzSlMuQ2hhcnQoJ2NoYXJ0Q29udGFpbmVyJywge1xyXG4gICAgICAgICAgICBheGlzWDoge1xyXG4gICAgICAgICAgICAgICAgdGl0bGU6IHBhcmFtVGl0bGUoY2hhbmdlZFBhcmFtKSxcclxuICAgICAgICAgICAgICAgIHRpdGxlRm9udFNpemU6IDE4XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGF4aXNZOiB7XHJcbiAgICAgICAgICAgICAgICB0aXRsZTogcGFyYW1UaXRsZShkYXRhYmFzZS5tZWFzdXJlZFBhcmFtc1swXSksXHJcbiAgICAgICAgICAgICAgICB0aXRsZUZvbnRTaXplOiAxNlxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBsZWdlbmQ6IHtcclxuICAgICAgICAgICAgICAgIHZlcnRpY2FsQWxpZ246ICdib3R0b20nLFxyXG4gICAgICAgICAgICAgICAgaG9yaXpvbnRhbEFsaWduOiAnY2VudGVyJ1xyXG4gICAgICAgICAgICB9LFxyXG5cclxuICAgICAgICAgICAgZGF0YVxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBjaGFydC5yZW5kZXIoKTtcclxuXHJcbiAgICAgICAgZmlsbERhdGFUYWJsZShkYXRhKTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBmaWxsRGF0YVRhYmxlKGRhdGEpIHtcclxuICAgICAgICBjb25zdCB0aGVhZCA9IGNsZWFyRWwocXVlcnlFbChgJHtyb290fS50YWJsZS1wYW5lbCB0YWJsZSB0aGVhZGApKTtcclxuICAgICAgICBjb25zdCB0Ym9keSA9IGNsZWFyRWwocXVlcnlFbChgJHtyb290fS50YWJsZS1wYW5lbCB0YWJsZSB0Ym9keWApKTtcclxuXHJcbiAgICAgICAgY29uc3QgZGF0YTIgPSBbXTtcclxuXHJcbiAgICAgICAgY29uc3Qga2V5cyA9IFsndHJhY2sgbmFtZScsICd1bml0cyddLmNvbmNhdChkYXRhWzBdLmRhdGFQb2ludHMubWFwKFIucHJvcCgneCcpKSk7XHJcbiAgICAgICAgZGF0YTIucHVzaChrZXlzKTtcclxuICAgICAgICBhZGRFbCh0aGVhZCwgYWRkRWxzKG1ha2VFbCgndHInKSwga2V5cy5tYXAobWFrZVRleHQpLm1hcChlbCA9PiBhZGRFbChtYWtlRWwoJ3RoJyksIGVsKSkpKTtcclxuXHJcbiAgICAgICAgYWRkRWxzKHRib2R5LCBkYXRhLm1hcCgocm93KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHZhbHMgPSBbcm93LmxlZ2VuZFRleHQsIHJvdy51bml0c10uY29uY2F0KHJvdy5kYXRhUG9pbnRzLm1hcChSLnByb3AoJ3knKSkpO1xyXG4gICAgICAgICAgICBkYXRhMi5wdXNoKHZhbHMpO1xyXG4gICAgICAgICAgICByZXR1cm4gYWRkRWxzKG1ha2VFbCgndHInKSwgdmFscy5tYXAobWFrZVRleHQpLm1hcChlbCA9PiBhZGRFbChtYWtlRWwoJ3RkJyksIGVsKSkpO1xyXG4gICAgICAgIH0pKTtcclxuICAgICAgICBzdGF0ZS5kYXRhID0gZGF0YTI7XHJcbiAgICB9XHJcblxyXG5cclxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby12YXIsdmFycy1vbi10b3BcclxuICAgIHZhciBtYWtlUmF3RGF0YUxpbmVzID0gUi5jdXJyeSgoc2NhbGVyLCBkYXRhYmFzZSwgY2hhbmdlZFBhcmFtLCBtZWFzdXJlZFBhcmFtKSA9PiB7XHJcbiAgICAgICAgY29uc3QgcGFzc2VzID0gUi5ncm91cEJ5KGl0ZW0gPT4gaXRlbS5wYXNzSWQsIFIudmFsdWVzKGRhdGFiYXNlLm1lYXN1cmVzKSk7XHJcblxyXG4gICAgICAgIGNvbnN0IGRhdGFQb2ludHMgPSBSLm1hcChwYXNzQXJyYXkgPT4gcGFzc0FycmF5Lm1hcChpdGVtID0+ICh7XHJcbiAgICAgICAgICAgIHg6IGl0ZW1bY2hhbmdlZFBhcmFtLm5hbWVdLFxyXG4gICAgICAgICAgICB5OiBzY2FsZXIoaXRlbVttZWFzdXJlZFBhcmFtLm5hbWVdKSxcclxuICAgICAgICAgICAgdG9vbFRpcENvbnRlbnQ6IEwxMG4uZm9ybWF0KFxyXG4gICAgICAgICAgICAgICAgJ3BlcmZvcm1hbmNlJywgJ3Rvb2x0aXAtc2NoZW1hJyxcclxuICAgICAgICAgICAgICAgIFtcclxuICAgICAgICAgICAgICAgICAgICBtZWFzdXJlZFBhcmFtLm5hbWUsXHJcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5wYXNzSWQsXHJcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1UaXRsZShjaGFuZ2VkUGFyYW0pLFxyXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1bY2hhbmdlZFBhcmFtLm5hbWVdLFxyXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtVGl0bGUobWVhc3VyZWRQYXJhbSksXHJcbiAgICAgICAgICAgICAgICAgICAgaXRlbVttZWFzdXJlZFBhcmFtLm5hbWVdXHJcbiAgICAgICAgICAgICAgICBdXHJcbiAgICAgICAgICAgIClcclxuICAgICAgICB9KSksIHBhc3Nlcyk7XHJcblxyXG4gICAgICAgIHJldHVybiBSLnZhbHVlcyhSLm1hcE9iakluZGV4ZWQoKGFycmF5LCBrZXkpID0+ICh7XHJcbiAgICAgICAgICAgIHNob3dJbkxlZ2VuZDogdHJ1ZSxcclxuICAgICAgICAgICAgbGVnZW5kVGV4dDogYCR7bWVhc3VyZWRQYXJhbS5uYW1lfSAke2tleX1gLFxyXG4gICAgICAgICAgICB0eXBlOiAnbGluZScsXHJcbiAgICAgICAgICAgIG1hcmtlclR5cGU6ICdjaXJjbGUnLFxyXG4gICAgICAgICAgICBtYXJrZXJCb3JkZXJDb2xvcjogJ2JsYWNrJyxcclxuICAgICAgICAgICAgbWFya2VyU2l6ZTogMTUsXHJcbiAgICAgICAgICAgIG1hcmtlckJvcmRlclRoaWNrbmVzczogMSxcclxuICAgICAgICAgICAgdW5pdHM6IG1lYXN1cmVkUGFyYW0udW5pdHMsXHJcbiAgICAgICAgICAgIGRhdGFQb2ludHM6IGFycmF5XHJcbiAgICAgICAgfSksIGRhdGFQb2ludHMpKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IG1ha2VBZ2dyZWdhdGVkRGF0YUxpbmVzID1cclxuICAgICAgICBSLmN1cnJ5KChsYWJlbCwgYWdncmVnYXRpb25GdW5jdGlvbiwgc2NhbGVyLCBkYXRhYmFzZSwgY2hhbmdlZFBhcmFtLCBtZWFzdXJlZFBhcmFtKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHBvaW50ZWQgPSBSLmdyb3VwQnkoaXRlbSA9PiBpdGVtW2NoYW5nZWRQYXJhbS5uYW1lXSwgUi52YWx1ZXMoZGF0YWJhc2UubWVhc3VyZXMpKTtcclxuXHJcbiAgICAgICAgICAgIGxldCBhdmcgPSBSLm1hcCgodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGNsb25lID0gUi5jbG9uZSh2YWx1ZVswXSk7XHJcbiAgICAgICAgICAgICAgICBjb25zdCByYXdWYWx1ZXMgPSBSLmFwKFtSLnByb3AobWVhc3VyZWRQYXJhbS5uYW1lKV0sIHZhbHVlKS5zb3J0KCk7XHJcbiAgICAgICAgICAgICAgICBjbG9uZVttZWFzdXJlZFBhcmFtLm5hbWVdID0gc2NhbGVyKGFnZ3JlZ2F0aW9uRnVuY3Rpb24ocmF3VmFsdWVzKSk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xvbmU7XHJcbiAgICAgICAgICAgIH0sIHBvaW50ZWQpO1xyXG5cclxuICAgICAgICAgICAgYXZnID0gUi52YWx1ZXMoYXZnKS5tYXAoaXRlbSA9PiAoe1xyXG4gICAgICAgICAgICAgICAgeDogaXRlbVtjaGFuZ2VkUGFyYW0ubmFtZV0sXHJcbiAgICAgICAgICAgICAgICB5OiBpdGVtW21lYXN1cmVkUGFyYW0ubmFtZV0sXHJcbiAgICAgICAgICAgICAgICB0b29sVGlwQ29udGVudDogc3RyRm9ybWF0KFxyXG4gICAgICAgICAgICAgICAgICAgICd7MH06IHsxfTxici8+ezJ9OiB7M30nLFxyXG4gICAgICAgICAgICAgICAgICAgIFtwYXJhbVRpdGxlKGNoYW5nZWRQYXJhbSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW1bY2hhbmdlZFBhcmFtLm5hbWVdLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbVRpdGxlKG1lYXN1cmVkUGFyYW0pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtW21lYXN1cmVkUGFyYW0ubmFtZV1dXHJcbiAgICAgICAgICAgICAgICApXHJcbiAgICAgICAgICAgIH0pKTtcclxuXHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBzaG93SW5MZWdlbmQ6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBsZWdlbmRUZXh0OiBgJHttZWFzdXJlZFBhcmFtLm5hbWV9ICR7bGFiZWx9YCxcclxuICAgICAgICAgICAgICAgIHR5cGU6ICdsaW5lJyxcclxuICAgICAgICAgICAgICAgIG1hcmtlclR5cGU6ICdjaXJjbGUnLFxyXG4gICAgICAgICAgICAgICAgbWFya2VyQm9yZGVyQ29sb3I6ICdibGFjaycsXHJcbiAgICAgICAgICAgICAgICBtYXJrZXJTaXplOiAzMCxcclxuICAgICAgICAgICAgICAgIG1hcmtlckJvcmRlclRoaWNrbmVzczogMSxcclxuICAgICAgICAgICAgICAgIHVuaXRzOiBtZWFzdXJlZFBhcmFtLnVuaXRzLFxyXG4gICAgICAgICAgICAgICAgZGF0YVBvaW50czogYXZnXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXZhcix2YXJzLW9uLXRvcFxyXG4gICAgdmFyIG1ha2VNZWRpYW5EYXRhTGluZXMgPSBtYWtlQWdncmVnYXRlZERhdGFMaW5lcygnbWVkaWFuJywgUi5tZWRpYW4pO1xyXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXZhcix2YXJzLW9uLXRvcFxyXG4gICAgdmFyIG1ha2VBdmdEYXRhTGluZXMgPSBtYWtlQWdncmVnYXRlZERhdGFMaW5lcygnYXZnJywgUi5tZWFuKTtcclxufSkodGhpcy5QZXJmb3JtYW5jZSA9IHt9KTtcclxuIiwiLypDb3B5cmlnaHQgMjAxNyBUaW1vZmV5IFJlY2hrYWxvdiA8bnRzZGtAeWFuZGV4LnJ1PlxyXG5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuXHJcbmh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAgICBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbigoZXhwb3J0cykgPT4ge1xyXG4gICAgY29uc3Qgcm9vdCA9ICcuLXRhYiAnO1xyXG4gICAgY29uc3Qgc3RhdGUgPSB7fTtcclxuXHJcbiAgICBleHBvcnRzLmluaXQgPSAoKSA9PiB7XHJcbiAgICAgICAgZXhwb3J0cy5jb250ZW50ID0gcXVlcnlFbChyb290KTtcclxuICAgIH07XHJcblxyXG4gICAgZXhwb3J0cy5yZWZyZXNoID0gKCkgPT4ge1xyXG5cclxuICAgIH07XHJcbn0pKHRoaXMuVGVtcGxhdGUgPSB7fSk7XHJcbiIsIi8qQ29weXJpZ2h0IDIwMTcgVGltb2ZleSBSZWNoa2Fsb3YgPG50c2RrQHlhbmRleC5ydT5cclxuXHJcbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcblxyXG5odHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gICAgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG4oKGV4cG9ydHMpID0+IHtcclxuICAgIGV4cG9ydHMuaW5pdCA9ICgpID0+IHtcclxuICAgICAgICBleHBvcnRzLmNvbnRlbnQgPSBnZXRFbCgnYWJvdXREaXYnKTtcclxuICAgIH07XHJcblxyXG4gICAgZXhwb3J0cy5yZWZyZXNoID0gKCkgPT4ge1xyXG4gICAgfTtcclxufSkodGhpcy5BYm91dCA9IHt9KTtcclxuIl0sInNvdXJjZVJvb3QiOiIvc291cmNlLyJ9

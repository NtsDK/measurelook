/*Copyright 2017 Timofey Rechkalov <ntsdk@yandex.ru>

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
    limitations under the License. */

'use strict';

function makeLocalDBMS(fullVersion) {
    const opts = {
        Migrator,
        CommonUtils,
        EventEmitter,
        Precondition,
        R,
        Ajv,
        Schema,
        Errors,
        listeners: {},
        Constants,
        dbmsUtils: {},
        dateFormat,
    };

    function LocalDBMS() {
        this._init(opts.listeners);
    }

    LocalDBMS.prototype.getSettings = () => this.database.Settings;

    const func = name => window[name](LocalDBMS, opts);

    [
        'baseAPI',
        'consistencyCheckAPI',
        //        'logAPI',
        //        'charsheetAPI',
        //        'settingsAPI',
    ].map(func);

    //    Logger.attachLogCalls(LocalDBMS, R, false);
    return LocalDBMS;
}

/*Copyright 2015-2017 Timofey Rechkalov <ntsdk@yandex.ru>, Maria Sidekhmenova <matilda_@list.ru>

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
    limitations under the License. */

'use strict';

((exports) => {
    const state = {};

    exports.init = (callback) => {
        state.callback = callback;
    };

    exports.makeNewBase = () => {
        Utils.confirm(getL10n('utils-new-base-warning'), () => {
            DBMS.setDatabase(CommonUtils.clone(EmptyBase.data), state.callback);
        });
    };

    exports.openHelp = () => {
        window.open('extras/doc/nims.html');
    };

    exports.readSingleFile = (evt) => {
        // Retrieve the first (and only!) File from the FileList object
        const f = evt.target.files[0];

        if (f) {
            const r = new FileReader();
            r.onload = (e) => {
                const contents = e.target.result;
                const database = JSON.parse(contents);
                DBMS.setDatabase(database, state.callback);
            };
            r.readAsText(f);
        } else {
            Utils.alert(getL10n('utils-base-file-loading-error'));
        }
    };

    exports.saveFile = () => {
        DBMS.getDatabase((err, database) => {
            if (err) { Utils.handleError(err); return; }
            exports.json2File(database, `${BASE_FILE_NAME}.json`);
        });
    };

    exports.json2File = (str, fileName) => {
        exports.str2File(JSON.stringify(str, null, '  '), fileName);
    };

    exports.str2File = (str, fileName) => {
        const blob = new Blob([str], {
            type: 'text/plain;charset=utf-8'
        });
        saveAs(blob, fileName);
    };

    function preprocessCsvStr(str) {
        if (!(typeof str === 'string' || str instanceof String)) {
            return str;
        }
        let result = str.replace(/"/g, '""');
        if (result.search(/("|,|\n)/g) >= 0) {
            result = `"${result}"`;
        }
        return result;
    }

    exports.arr2d2Csv = (arr, fileName) => {
        const csv = `\ufeff${arr.map(dataArray => dataArray.map(preprocessCsvStr).join(';')).join('\n')}`;

        const out = new Blob([csv], {
            type: 'text/csv;charset=utf-8;'
        });
        saveAs(out, fileName);
    };
})(this.FileUtils = {});

/*Copyright 2015-2017 Timofey Rechkalov <ntsdk@yandex.ru>, Maria Sidekhmenova <matilda_@list.ru>

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
    limitations under the License. */

'use strict';

/* eslint-disable no-var,vars-on-top */

((exports, Dictionaries) => {
    const state = {};

    state.initialized = false;
    state.l10nDelegates = [];
    state.dictionaries = {};
    state.lang = defaultLang;

    const init = () => {
        if (state.initialized) {
            return;
        }
        //        console.log(navigator.language);

        state.dictionaries = R.map(processDictionary, Dictionaries);

        //    var lang = (navigator.languages ? navigator.languages[0] : navigator.browserLanguage).split('-')[0];
        //    var lang = 'ru';
        //        var lang = defaultLang;
        //        console.log(lang);

        if (state.dictionaries[defaultLang]) {
            state.dict = state.dictionaries[defaultLang];
        } else {
            state.dict = state.dictionaries.en;
        }
        setHtmlLang(defaultLang);
        exports.onL10nChange(exports.localizeStatic);
        state.initialized = true;
    };

    var processDictionary = (dictionary) => {
        const processedDictionary = {};
        R.toPairs(dictionary).forEach(([sectionName, section]) => {
            R.toPairs(section).forEach(([key, value]) => {
                processedDictionary[`${sectionName}-${key}`] = value;
            });
        });
        //        for (const sectionName in dictionary) {
        //            for (const name in dictionary[sectionName]) {
        //                processedDictionary[`${sectionName}-${name}`] = dictionary[sectionName][name];
        //            }
        //        }
        return processedDictionary;
    };

    var setHtmlLang = lang => setAttr(document.getElementsByTagName('html')[0], 'lang', lang);

    exports.toggleL10n = () => {
        if (state.lang === 'ru') {
            state.dict = state.dictionaries.en;
            state.lang = 'en';
        } else {
            state.dict = state.dictionaries.ru;
            state.lang = 'ru';
        }
        setHtmlLang(state.lang);
        state.l10nDelegates.forEach((delegate) => {
            delegate();
        });
    };

    exports.getLang = () => state.lang.toLowerCase();

    exports.format = R.curry((namespace, name, args) => strFormat(exports.get(namespace, name), args));

    exports.get = R.curry((namespace, name) => L10n.getValue(`${namespace}-${name}`));

    exports.getValue = (name) => {
        const value = state.dict[name];
        if (value === undefined) console.log(`Value is not found: ${name}`);
        return value || `${name}:RA RA-AH-AH-AH ROMA ROMA-MA GAGA OH LA-LA`;
    };

    exports.onL10nChange = (delegate) => {
        state.l10nDelegates.push(delegate);
    };

    exports.localizeStatic = () => {
        init();
        nl2array(document.querySelectorAll('[l10n-id]')).map(el => addEl(clearEl(el), makeText(exports.getValue(getAttr(el, 'l10n-id')))));
        nl2array(document.querySelectorAll('[l10n-placeholder-id]')).map(el => setAttr(el, 'placeholder', exports.getValue(getAttr(el, 'l10n-placeholder-id'))));
    };
})(this.L10n = {}, Dictionaries);

/*Copyright 2015-2017 Timofey Rechkalov <ntsdk@yandex.ru>, Maria Sidekhmenova <matilda_@list.ru>

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
    limitations under the License. */

'use strict';

/* eslint-disable no-var,vars-on-top */

((exports) => {
    exports.initTabPanel = (tabClazz, containerClazz) => {
        const containers = getEls(containerClazz);

        let i;
        for (i = 1; i < containers.length; i++) { // don't hide 1st element
            addClass(containers[i], 'hidden');
        }

        const tabButtons = getEls(tabClazz);

        addClass(tabButtons[0], 'active');

        for (i = 0; i < tabButtons.length; i++) {
            listen(tabButtons[i], 'click', tabButtonClick(tabButtons, containers));
        }
    };

    var tabButtonClick = (buttons, containers) => (event) => {
        for (let i = 0; i < buttons.length; i++) {
            setClassByCondition(buttons[i], 'active', event.target.id === buttons[i].id);
        }
        for (let i = 0; i < containers.length; i++) {
            setClassByCondition(containers[i], 'hidden', `${event.target.id}Container` !== containers[i].id);
        }
    };

    exports.fillShowItemSelector = (selector, displayArray) => {
        let el;
        setAttr(selector, 'size', displayArray.length);
        displayArray.forEach((value) => {
            el = setProps(makeEl('option'), {
                selected: true,
            });
            setClassByCondition(el, 'hidden', value.hidden);
            addEl(selector, addEl(el, makeText(value.name)));
        });
    };

    exports.fillShowItemSelector2 = (selector, optionGroups) => {
        let el, groupEl, counter = 0;
        addEls(selector, optionGroups.map((group) => {
            counter++;
            groupEl = setAttr(makeEl('optgroup'), 'label', group.name);
            addEls(groupEl, group.array.map((value) => {
                el = setProps(makeEl('option'), {
                    selected: true,
                });
                setClassByCondition(el, 'hidden', value.hidden);
                counter += (value.hidden ? 0 : 1);
                return addEl(el, makeText(value.name));
            }));
            return groupEl;
        }));
        setAttr(selector, 'size', counter);
    };

    exports.showSelectedEls = classKey => (event) => {
        const el = event.target;
        let els, i, j;
        for (i = 0; i < el.options.length; i += 1) {
            els = getEls(i + classKey);
            for (j = 0; j < els.length; j++) {
                setClassByCondition(els[j], 'hidden', !el.options[i].selected);
            }
        }
    };

    exports.initSelectorFilters = () => {
        const elems = document.querySelectorAll('[selector-filter]');
        let el, sel;
        for (let i = 0; i < elems.length; i++) {
            el = elems[i];
            sel = queryEl(getAttr(el, 'selector-filter'));
            el.value = '';
            listen(el, 'input', filterOptions(sel));
        }
    };

    var filterOptions = sel => (event) => {
        let val = event.target.value;
        let i, opt;
        val = CommonUtils.globStringToRegex(val.trim().toLowerCase());
        for (i = 0; i < sel.options.length; i += 1) {
            opt = sel.options[i];
            const isVisible = opt.innerHTML.toLowerCase().search(val) !== -1;
            if (!isVisible) {
                opt.selected = false;
            }
            setClassByCondition(opt, 'hidden', !isVisible);
            //                setClassByCondition(opt, "hidden", opt.innerHTML.toLowerCase().search(val) === -1);
        }
        sel.dispatchEvent(new Event('change'));
    };

    exports.initPanelTogglers = () => {
        const elems = document.querySelectorAll('[panel-toggler]');
        let el, sel, attr;
        for (let i = 0; i < elems.length; i++) {
            el = elems[i];
            attr = getAttr(el, 'panel-toggler');
            addClass(el, 'expanded');
            sel = document.querySelector(attr);
            if (sel == null) {
                Utils.alert(`Panel toggler is broken: ${attr}`);
            }
            listen(el, 'click', togglePanel(el, sel));
        }
    };
    
    exports.attachPanelToggler = (header, content, callback) => {
        addClass(header, 'expanded');
        listen(header, 'click', (event) => {
            if(callback) {
                callback(event, () => {
                    togglePanel(header, content)(event);
                });
            } else {
                togglePanel(header, content)(event);
            }
        });
    };

    var togglePanel = (el, sel) => (event) => {
        const isExpanded = hasClass(el, 'expanded');
        removeClasses(el, ['expanded', 'collapsed']);
        addClass(el, isExpanded ? 'collapsed' : 'expanded');
        toggleClass(sel, 'hidden');
    };
    
    exports.makeEventTimePicker = (opts) => {
        const input = makeEl('input');
        R.ap([addClass(input)], opts.extraClasses);
        addClass(input, 'eventTime');
        input.value = opts.eventTime;

        input.eventIndex = opts.index;

        const pickerOpts = {
            lang: L10n.getLang(),
            mask: true,
            startDate: new Date(opts.preGameDate),
            endDate: new Date(opts.date),
            onChangeDateTime: opts.onChangeDateTimeCreator(input),
        };

        if (opts.eventTime !== '') {
            pickerOpts.value = opts.eventTime;
        } else {
            pickerOpts.value = opts.date;
            addClass(input, 'defaultDate');
        }

        jQuery(input).datetimepicker(pickerOpts);
        return input;
    };

    // bug about setting 0900 years in Braavos game is event date. Fixed in production.
    //  exports.makeEventTimePicker = function (opts) {
    //      var input = makeEl("input");
    //      R.ap([addClass(input)], opts.extraClasses);
    //      addClass(input, "eventTime");
    //      input.value = opts.eventTime;
    //
    //      input.eventIndex = opts.index;
    //
    //      var pickerOpts = {
    //          lang : L10n.getLang(),
    //          mask : true,
    //          startDate : new Date(opts.preGameDate),
    //          endDate : new Date(opts.date),
    //          onChangeDateTime : opts.onChangeDateTimeCreator(input),
    //      };
    //
    //      var picker = jQuery(input).datetimepicker(pickerOpts);
    //
    //      var value;
    //      if (opts.eventTime !== "") {
    //          value = new Date(opts.eventTime);
    //      } else {
    //          value = opts.date;
    //          addClass(input, "defaultDate");
    //      }
    //
    //      picker.value = value;
    //
    //
    //      return input;
    //  };

    exports.resizeTextarea = (ev) => {
        const that = ev.target;
        that.style.height = '24px';
        that.style.height = `${that.scrollHeight + 12}px`;
    };

    exports.resizeTextarea2 = (that) => {
        that.style.height = '24px';
        that.style.height = `${that.scrollHeight + 12}px`;
    };

    exports.makeAdaptationTimeInput = (storyName, event, characterName, isEditable) => {
        const input = makeEl('input');
        setClassByCondition(input, 'notEditable', !isEditable);
        addClass(input, 'adaptationTimeInput');
        input.value = event.characters[characterName].time;
        input.dataKey = JSON.stringify([storyName, event.index, characterName]);
        listen(input, 'change', onChangePersonalTimeDelegate);
        return input;
    };

    var onChangePersonalTimeDelegate = (event) => {
        const dataKey = JSON.parse(event.target.dataKey);
        const time = event.target.value;
        DBMS.setEventAdaptationProperty(dataKey[0], dataKey[1], dataKey[2], 'time', time, Utils.processError());
    };

    exports.makeAdaptationReadyInput = (storyName, event, characterName, isEditable) => {
        const div = makeEl('div');
        const input = makeEl('input');
        setClassByCondition(input, 'notEditable', !isEditable);
        input.type = 'checkbox';
        input.checked = event.characters[characterName].ready;
        input.dataKey = JSON.stringify([storyName, event.index, characterName]);
        input.id = `${event.index}-${storyName}-${characterName}`;
        listen(input, 'change', onChangeReadyStatus);
        addEl(div, input);

        addEl(div, setAttr(addEl(makeEl('label'), makeText(constL10n(Constants.finishedText))), 'for', input.id));
        return div;
    };

    var onChangeReadyStatus = (event) => {
        const dataKey = JSON.parse(event.target.dataKey);
        const value = event.target.checked;
        DBMS.setEventAdaptationProperty(dataKey[0], dataKey[1], dataKey[2], 'ready', value, Utils.processError());
    };

    exports.makePanelCore = (title, content) => {
        const panel = addClasses(makeEl('div'), ['panel', 'panel-default']);
        const h3 = addClass(addEl(makeEl('h3'), title), 'panel-title');
        const a = setAttr(makeEl('a'), 'href', '#/');
        setAttr(a, 'panel-toggler', '');
        const headDiv = addClass(makeEl('div'), 'panel-heading');
        addEl(panel, addEl(headDiv, addEl(a, h3)));
        const contentDiv = addClass(makeEl('div'), 'panel-body');
        addEl(panel, addEl(contentDiv, content));
        return {
            panel,
            contentDiv,
            a
        };
    };

    exports.makeProfileTable = (profileStructure, profile) => {
        let value;
        const profileDiv = addEls(makeEl('tbody'), profileStructure.filter(element => element.doExport).map((element) => {
            switch (element.type) {
            case 'text':
                value = addClass(makeEl('span'), 'briefingTextSpan');
                addEl(value, makeText(profile[element.name]));
                break;
            case 'enum':
            case 'multiEnum':
            case 'number':
            case 'string':
                value = makeText(profile[element.name]);
                break;
            case 'checkbox':
                value = makeText(constL10n(Constants[profile[element.name]]));
                break;
            default:
                throw new Error(`Unexpected type ${element.type}`);
            }
            return exports.makeTableRow(makeText(element.name), value);
        }));
        return addEl(addClasses(makeEl('table'), ['table', 'table-striped']), profileDiv);
    };

    exports.makeTableRow = (col1, col2) => addEls(makeEl('tr'), [addEl(makeEl('td'), col1), addEl(makeEl('td'), col2)]);
})(this.UI = {});

/*Copyright 2015-2017 Timofey Rechkalov <ntsdk@yandex.ru>, Maria Sidekhmenova <matilda_@list.ru>

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
    limitations under the License. */

'use strict';

// TODO need to lint utils with NIMS fixes
/* eslint-disable */

const strFormat = R.curry(CommonUtils.strFormat);

function getL10n(key) {
    return L10n.getValue(key);
}

function constL10n(key) {
    return L10n.getValue(`constant-${key}`);
}

function isEmpty(obj) {
    return (Object.getOwnPropertyNames(obj).length === 0);
}

const addClass = R.curry((o, c) => {
    const re = new RegExp(`(^|\\s)${c}(\\s|$)`, 'g');
    if (re.test(o.className)) return o;
    o.className = (`${o.className} ${c}`).replace(/\s+/g, ' ').replace(/(^ | $)/g, '');
    return o;
});

const addClasses = R.curry((o, c) => {
    R.ap([addClass(o)], c);
    return o;
});

const rAddClass = R.curry((c, o) => addClass(o, c));


const hasClass = R.curry((o, c) => {
    const re = new RegExp(`(^|\\s)${c}(\\s|$)`, 'g');
    return (re.test(o.className));
});

const removeClass = R.curry((o, c) => {
    const re = new RegExp(`(^|\\s)${c}(\\s|$)`, 'g');
    o.className = o.className.replace(re, '$1').replace(/\s+/g, ' ').replace(/(^ | $)/g, '');
    return o;
});

const removeClasses = R.curry((o, c) => {
    R.ap([removeClass(o)], c);
    return o;
});

const toggleClass = R.curry((o, c) => {
    if (hasClass(o, c)) {
        removeClass(o, c);
    } else {
        addClass(o, c);
    }
});

function setClassByCondition(o, c, condition) {
    if (condition) {
        addClass(o, c);
    } else {
        removeClass(o, c);
    }
    return o;
}

function getEl(id) {
    return document.getElementById(id);
}

function queryEl(sel) {
    return document.querySelector(sel);
}

function queryEls(sel) {
    return nl2array(document.querySelectorAll(sel));
}

function queryElEl(el, sel) {
    return el.querySelector(sel);
}

function queryElEls(el, sel) {
    return nl2array(el.querySelectorAll(sel));
}

function getEls(clazz) {
    return document.getElementsByClassName(clazz);
}

function makeEl(elTag) {
    return document.createElement(elTag);
}

function makeText(text) {
    return document.createTextNode(text);
}

const addEl = R.curry((parent, child) => {
    parent.appendChild(child);
    return parent;
});
const addEls = R.curry((parent, children) => {
    R.ap([addEl(parent)], children);
    return parent;
});

const makeOpt = function (label) {
    const option = makeEl('option');
    addEl(option, (makeText(label)));
    return option;
};

const rAddEl = R.curry((child, parent) => {
    parent.appendChild(child);
    return parent;
});


const setAttr = R.curry((el, name, value) => {
    el.setAttribute(name, value);
    return el;
});

const setStyle = R.curry((el, name, value) => {
    el.style.setProperty(name, value);
    return el;
});

const setImportantStyle = R.curry((el, name, value) => {
    el.style.setProperty(name, value, 'important');
    return el;
});

function delAttr(el, name) {
    el.removeAttribute(name);
    return el;
}

function getAttr(el, name) {
    return el.getAttribute(name);
}

const setProp = R.curry((el, key, value) => {
    el[key] = value;
    return el;
});

const setProps = R.curry((el, map) => {
    for (const key in map) {
        setProp(el, key, map[key]);
    }
    return el;
});

function clearEl(el) {
    Utils.removeChildren(el);
    return el;
}

function passEls(src, dst) {
    for (let i = 0; i < src.children.length; i++) {
        addEl(dst, src.children[i]);
    }
}

const listen = R.curry((el, event, listener) => {
    el.addEventListener(event, listener);
    return el;
});

const listenOnEnter = R.curry((el, callback) => {
    listen(el, 'keydown', (e) => {
        if (e.keyCode === 13) {
            callback();
        }
    });
});

const fillSelector = R.curry((sel, data) => addEls(sel, data.map((item) => {
    const opt = makeEl('option');
    addEl(opt, makeText(item.name));
    if (item.value !== undefined) { opt.value = item.value; }
    if (item.selected !== undefined) { opt.selected = true; }
    if (item.className !== undefined) { addClass(opt, item.className); }
    return opt;
})));

function nl2array(nodeList) {
    return Array.prototype.slice.call(nodeList);
}

const remapProps = R.curry((outKeys, pickKeys, obj) => R.compose(R.zipObj(outKeys), R.values, R.pick(pickKeys))(obj));

const remapProps4Select2 = remapProps(['id', 'text'], ['value', 'displayName']);
const remapProps4Select = remapProps(['value', 'name'], ['value', 'displayName']);

const getSelect2DataCommon = R.curry((preparator, obj) => R.compose(R.zipObj(['data']), R.append(R.__, []), R.map(preparator))(obj));

const getSelect2Data = getSelect2DataCommon(remapProps4Select2);

const makeSelect2Opt = R.compose(R.zipObj(['id', 'text']), R.repeat(R.__, 2));
const arr2Select2 = R.compose(R.assoc('data', R.__, {}), R.map(makeSelect2Opt));
const arr2Select = R.map(R.compose(R.zipObj(['value', 'name']), R.repeat(R.__, 2)));
const constArr2Select = R.map(R.compose(R.zipObj(['value', 'name']), name => [name, constL10n(name)]));

const getSelectedRadio = function (query) {
    const els = document.querySelectorAll(query);
    for (let i = 0; i < els.length; i++) {
        if (els[i].checked === true) {
            return els[i];
        }
    }
    return null;
};

const debugInterceptor = function (callback) {
    return function () {
        console.log(JSON.stringify(arguments[0]));
        callback(...arguments);
    };
};

const Utils = {};

/** opts
    tooltip - add tooltip to button, used for iconic buttons
    id - set button id
    mainPage - enable view as first page
    toggle - toggle content, associated with button
*/
Utils.addView = function (containers, name, view, opts2) {
    const opts = opts2 || {};
    view.init();
    const buttonClass = 'navigation-button';
    containers.root.views[name] = view;
    const button = makeEl('button');
    function delegate() {
        $(button).attr('data-original-title', L10n.getValue(`header-${name}`));
    }
    if (opts.tooltip) {
        L10n.onL10nChange(delegate);
        $(button).tooltip({
            title: L10n.getValue(`header-${name}`),
            placement: 'bottom'
        });
    } else {
        addEl(button, makeText(L10n.getValue(`header-${name}`)));
        setAttr(button, 'l10n-id', `header-${name}`);
    }
    addClass(button, buttonClass);
    addClass(button, `-test-${name}`);
    addClass(button, `-toggle-class-${name}`);
    if (opts.clazz) {
        addClass(button, opts.clazz);
    }
    containers.navigation.appendChild(button);

    const onClickDelegate = function (view2) {
        return function (evt) {
            //Tests.run();
            const elems = containers.navigation.getElementsByClassName(buttonClass);
            if (opts.toggle) {
                const els = getEls(`-toggle-class-${name}`);
                for (let i = 0; i < els.length; i++) {
                    if (evt.target.isEqualNode(els[i])) {
                        continue;
                    }
                    if (hasClass(els[i], 'active')) {
                        els[i].click();
                    }
                }
            }

            const isActive = hasClass(evt.target, 'active');
            for (let i = 0; i < elems.length; i++) {
                removeClass(elems[i], 'active');
            }
            if (!opts.toggle || (opts.toggle && !isActive)) {
                addClass(evt.target, 'active');

                passEls(containers.content, getEl('warehouse'));
                containers.content.appendChild(view2.content);
                removeClass(containers.content, 'hidden');
                containers.root.currentView = view2;
                view2.refresh();
            } else {
                removeClass(evt.target, 'active');
                passEls(containers.content, getEl('warehouse'));
                containers.root.currentView = null;
                addClass(containers.content, 'hidden');
            }
        };
    };

    button.addEventListener('click', onClickDelegate(view));
    if (opts.mainPage) {
        addClass(button, 'active');
        containers.content.appendChild(view.content);
        containers.root.currentView = view;
    }
};

Utils.alert = function (message) {
    vex.dialog.alert(message);
};

Utils.confirm = function (message, onOk, onCancel) {
    vex.dialog.confirm({
        message,
        callback: (val) => {
            if (val) {
                if (onOk) onOk();
            } else if (onCancel) onCancel();
        }
    });
};

Utils.removeChildren = function (myNode) {
    if (!myNode) {
        return;
    }
    while (myNode.firstChild) {
        myNode.removeChild(myNode.firstChild);
    }
};

Utils.processError = function (callback) {
    return function (err) {
        if (err) {
            Utils.handleError(err);
            return;
        }

        if (callback) {
            const arr = [];
            for (let i = 1; i < arguments.length; i++) {
                arr.push(arguments[i]);
            }
            callback(...arr);
        }
    };
};

Utils.handleErrorMsg = function (err) {
    const checkErrorType = R.curry((err2, name) => err2 instanceof Errors[name] || (err2.name && err2.name === name));
    if (R.keys(Errors).some(checkErrorType(err))) {
        return strFormat(getL10n(err.messageId), err.parameters);
    } else if (typeof err === 'object') {
        return err.message;
    }
    return err;
};

Utils.handleError = err => Utils.alert(Utils.handleErrorMsg(err));

Utils.enableEl = R.curry((el, condition) => {
    const key = el.tagName.toLowerCase() === 'textarea' ? 'readonly' : 'disabled';
    if (condition) {
        el.removeAttribute(key);
    } else {
        el.setAttribute(key, key);
    }
});

Utils.enable = function (root, className, condition) {
    nl2array(root.getElementsByClassName(className)).map(Utils.enableEl(R.__, condition));
};

Utils.charOrdAObject = CommonUtils.charOrdAFactory(a => a.displayName.toLowerCase());

Utils.rebuildSelector = function (selector, names) {
    clearEl(selector);
    names.forEach((nameInfo) => {
        const option = makeEl('option');
        option.appendChild(makeText(nameInfo.displayName));
        option.value = nameInfo.value;
        selector.appendChild(option);
    });
};

Utils.rebuildSelectorArr = function (selector, names) {
    clearEl(selector);
    names.forEach((name) => {
        const option = makeEl('option');
        option.appendChild(makeText(name));
        selector.appendChild(option);
    });
};

String.prototype.endsWith = function (suffix) {
    return this.indexOf(suffix, this.length - suffix.length) !== -1;
};

// from date format utils
//For convenience...
Date.prototype.format = function (mask, utc) {
    return dateFormat(this, mask, utc);
};

/*Copyright 2017 Timofey Rechkalov <ntsdk@yandex.ru>

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
    limitations under the License. */

'use strict';

((exports) => {
    const state = {};
    state.views = {};

    const btnOpts = {
        tooltip: true,
        className: 'mainNavButton'
    };

    exports.onMasterPageLoad = () => {
        initPage();
        const LocalDBMS = makeLocalDBMS(true);
        if (MODE === 'Standalone') {
            window.DBMS = new LocalDBMS();
            DBMS.setDatabase(BaseExample.data, (err) => {
                if (err) { Utils.handleError(err); return; }
                consistencyCheck(onDatabaseLoad);
            });
        } else if (MODE === 'NIMS_Server') {
            const RemoteDBMS = makeRemoteDBMS(LocalDBMS);
            window.DBMS = new RemoteDBMS();
            consistencyCheck(onDatabaseLoad);
        }
    };

    function onDatabaseLoad() {
        //        initTheme();

        stateInit();

        Utils.addView(state.containers, 'performance', Performance, { mainPage: true });
        //        Utils.addView(state.containers, 'instruction', Instruction);

        addEl(state.navigation, addClass(makeEl('div'), 'nav-separator'));

        Utils.addView(state.containers, 'about', About);

        addEl(state.navigation, makeButton('testButton', 'test', runTests, btnOpts));

        const button = makeButton('dataLoadButton', 'open-database', null, btnOpts);
        button.addEventListener('change', FileUtils.readSingleFile, false);

        const input = makeEl('input');
        input.type = 'file';
        addClass(input, 'hidden');
        setAttr(input, 'tabindex', -1);
        button.appendChild(input);
        button.addEventListener('click', (e) => {
            input.value = '';
            input.click();
        });
        addEl(state.navigation, button);

        //                addEl(state.navigation, makeButton("themeButton", "theme", () => nextTheme(), btnOpts));
        addEl(state.navigation, makeButton('dataSaveButton', 'save-database', FileUtils.saveFile, btnOpts));
        //if (MODE === 'Standalone') {
        //  addEl(state.navigation, makeButton('newBaseButton', 'create-database', FileUtils.makeNewBase, btnOpts));
        //}
        //addEl(state.navigation, makeButton("mainHelpButton", "docs", FileUtils.openHelp, btnOpts));

        addEl(state.navigation, makeL10nButton());

        //        Utils.addView(state.containers, 'logViewer', LogViewer2, { clazz: 'logViewerButton', tooltip: true });
        //        addEl(state.navigation, makeButton('testButton', 'test', runTests, btnOpts));

        //addEl(state.navigation, makeButton("refreshButton", "refresh", () => state.currentView.refresh(), btnOpts));

        FileUtils.init((err) => {
            if (err) { Utils.handleError(err); return; }
            consistencyCheck(state.currentView.refresh);
        });

        state.currentView.refresh();
        addBeforeUnloadListener();
    }

    function initPage() {
        L10n.localizeStatic();
        L10n.onL10nChange(() => state.currentView.refresh());
        UI.initSelectorFilters();
        UI.initPanelTogglers();
        function updateDialogs() {
            vex.dialog.buttons.YES.text = getL10n('common-ok');
            vex.dialog.buttons.NO.text = getL10n('common-cancel');
        }
        updateDialogs();
        L10n.onL10nChange(updateDialogs);
    }

    //    var curTheme = Constants.themeList[1];
    //
    //    var initTheme = function() {
    //        if(DBMS.setTheme){
    //            DBMS.getTheme(function(err, theme){
    //                if(err) {console.log(err);}
    //                if(theme !== ''){
    //                    curTheme = theme;
    //                }
    //                addClass(queryEl('body'), curTheme);
    //            });
    //        } else {
    //            addClass(queryEl('body'), curTheme);
    //        }
    //    };
    //
    //    var nextTheme = function() {
    //        removeClass(queryEl('body'), curTheme);
    //        curTheme = Constants.themeList[(R.indexOf(curTheme, Constants.themeList)+1)%Constants.themeList.length];
    //        addClass(queryEl('body'), curTheme);
    //        if(DBMS.setTheme){
    //            DBMS.setTheme(curTheme, function(err){
    //                if(err) {console.log(err); return;}
    //            });
    //        }
    //    };

    function consistencyCheck(callback) {
        DBMS.getConsistencyCheckResult((err, consistencyErrors) => {
            if (err) { Utils.handleError(err); return; }
            consistencyErrors.forEach(CommonUtils.consoleLog);
            if (consistencyErrors.length > 0) {
                Utils.alert(getL10n('overview-consistency-problem-detected'));
            } else {
                console.log('Consistency check didn\'t find errors');
            }
            callback();
        });
    }

    function stateInit() {
        state.navigation = getEl('navigation');
        state.containers = {
            root: state,
            navigation: state.navigation,
            content: getEl('contentArea')
        };
    }

    function runTests() {
        DBMS.getConsistencyCheckResult((err, consistencyErrors) => {
            if (err) { Utils.handleError(err); return; }
            consistencyErrors.forEach(CommonUtils.consoleLog);
            if (consistencyErrors.length > 0) {
                Utils.alert(getL10n('overview-consistency-problem-detected'));
            } else {
                Utils.alert(getL10n('overview-consistency-is-ok'));
                console.log('Consistency check didn\'t find errors');
            }
        });
    }

    function makeButton(clazz, name, callback, opts) {
        const button = makeEl('button');
        addClass(button, clazz);
        function delegate() {
            $(button).attr('data-original-title', L10n.getValue(`header-${name}`));
        }
        if (opts.tooltip) {
            L10n.onL10nChange(delegate);
            $(button).tooltip({
                title: L10n.getValue(`header-${name}`),
                placement: 'bottom'
            });
        }
        addClass(button, 'action-button');
        if (opts.className) {
            addClass(button, opts.className);
        }
        if (callback) {
            listen(button, 'click', callback);
        }
        return button;
    }

    function makeL10nButton() {
        const l10nBtn = makeButton('toggleL10nButton', 'l10n', L10n.toggleL10n, btnOpts);
        function setIcon() {
            l10nBtn.style.backgroundImage = strFormat('url("./images/{0}.svg")', [getL10n('header-dictionary-icon')]);
        }
        L10n.onL10nChange(setIcon);
        setIcon();
        return l10nBtn;
    }

    function addBeforeUnloadListener() {
        window.onbeforeunload = (evt) => {
            const message = getL10n('utils-close-page-warning');
            if (typeof evt === 'undefined') {
                evt = window.event;
            }
            if (evt) {
                evt.returnValue = message;
            }
            return message;
        };
    }
    
    listen(window, 'paste', function (evt) {
        try{
            JSON.parse(evt.clipboardData.getData("text"))
        } catch(e){
            Utils.alert('Error on parsing base ' + e);
            return;
        }
        DBMS.setDatabase(JSON.parse(evt.clipboardData.getData("text")), (err) => {
            if (err) { Utils.handleError(err); return; }
            consistencyCheck(state.currentView.refresh);
        });
    });
})(this.PageManager = {});

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImpzL2RibXMvbG9jYWxEQk1TLmpzIiwiLi4vY29yZS9qcy9maWxlVXRpbHMuanMiLCIuLi9jb3JlL2pzL2wxMG4uanMiLCIuLi9jb3JlL2pzL3VpVXRpbHMuanMiLCIuLi9jb3JlL2pzL3V0aWxzLmpzIiwianMvcGFnZU1hbmFnZXIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUNuREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQ3RHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUMzU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUM5WkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJzY3JpcHRzLm1pbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qQ29weXJpZ2h0IDIwMTcgVGltb2ZleSBSZWNoa2Fsb3YgPG50c2RrQHlhbmRleC5ydT5cclxuXHJcbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcblxyXG5odHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gICAgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG5mdW5jdGlvbiBtYWtlTG9jYWxEQk1TKGZ1bGxWZXJzaW9uKSB7XHJcbiAgICBjb25zdCBvcHRzID0ge1xyXG4gICAgICAgIE1pZ3JhdG9yLFxyXG4gICAgICAgIENvbW1vblV0aWxzLFxyXG4gICAgICAgIEV2ZW50RW1pdHRlcixcclxuICAgICAgICBQcmVjb25kaXRpb24sXHJcbiAgICAgICAgUixcclxuICAgICAgICBBanYsXHJcbiAgICAgICAgU2NoZW1hLFxyXG4gICAgICAgIEVycm9ycyxcclxuICAgICAgICBsaXN0ZW5lcnM6IHt9LFxyXG4gICAgICAgIENvbnN0YW50cyxcclxuICAgICAgICBkYm1zVXRpbHM6IHt9LFxyXG4gICAgICAgIGRhdGVGb3JtYXQsXHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIExvY2FsREJNUygpIHtcclxuICAgICAgICB0aGlzLl9pbml0KG9wdHMubGlzdGVuZXJzKTtcclxuICAgIH1cclxuXHJcbiAgICBMb2NhbERCTVMucHJvdG90eXBlLmdldFNldHRpbmdzID0gKCkgPT4gdGhpcy5kYXRhYmFzZS5TZXR0aW5ncztcclxuXHJcbiAgICBjb25zdCBmdW5jID0gbmFtZSA9PiB3aW5kb3dbbmFtZV0oTG9jYWxEQk1TLCBvcHRzKTtcclxuXHJcbiAgICBbXHJcbiAgICAgICAgJ2Jhc2VBUEknLFxyXG4gICAgICAgICdjb25zaXN0ZW5jeUNoZWNrQVBJJyxcclxuICAgICAgICAvLyAgICAgICAgJ2xvZ0FQSScsXHJcbiAgICAgICAgLy8gICAgICAgICdjaGFyc2hlZXRBUEknLFxyXG4gICAgICAgIC8vICAgICAgICAnc2V0dGluZ3NBUEknLFxyXG4gICAgXS5tYXAoZnVuYyk7XHJcblxyXG4gICAgLy8gICAgTG9nZ2VyLmF0dGFjaExvZ0NhbGxzKExvY2FsREJNUywgUiwgZmFsc2UpO1xyXG4gICAgcmV0dXJuIExvY2FsREJNUztcclxufVxyXG4iLCIvKkNvcHlyaWdodCAyMDE1LTIwMTcgVGltb2ZleSBSZWNoa2Fsb3YgPG50c2RrQHlhbmRleC5ydT4sIE1hcmlhIFNpZGVraG1lbm92YSA8bWF0aWxkYV9AbGlzdC5ydT5cclxuXHJcbkxpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XHJcbnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cclxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XHJcblxyXG5odHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcclxuXHJcblVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcclxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxyXG5XSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cclxuU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxyXG4gICAgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuICovXHJcblxyXG4ndXNlIHN0cmljdCc7XHJcblxyXG4oKGV4cG9ydHMpID0+IHtcclxuICAgIGNvbnN0IHN0YXRlID0ge307XHJcblxyXG4gICAgZXhwb3J0cy5pbml0ID0gKGNhbGxiYWNrKSA9PiB7XHJcbiAgICAgICAgc3RhdGUuY2FsbGJhY2sgPSBjYWxsYmFjaztcclxuICAgIH07XHJcblxyXG4gICAgZXhwb3J0cy5tYWtlTmV3QmFzZSA9ICgpID0+IHtcclxuICAgICAgICBVdGlscy5jb25maXJtKGdldEwxMG4oJ3V0aWxzLW5ldy1iYXNlLXdhcm5pbmcnKSwgKCkgPT4ge1xyXG4gICAgICAgICAgICBEQk1TLnNldERhdGFiYXNlKENvbW1vblV0aWxzLmNsb25lKEVtcHR5QmFzZS5kYXRhKSwgc3RhdGUuY2FsbGJhY2spO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBleHBvcnRzLm9wZW5IZWxwID0gKCkgPT4ge1xyXG4gICAgICAgIHdpbmRvdy5vcGVuKCdleHRyYXMvZG9jL25pbXMuaHRtbCcpO1xyXG4gICAgfTtcclxuXHJcbiAgICBleHBvcnRzLnJlYWRTaW5nbGVGaWxlID0gKGV2dCkgPT4ge1xyXG4gICAgICAgIC8vIFJldHJpZXZlIHRoZSBmaXJzdCAoYW5kIG9ubHkhKSBGaWxlIGZyb20gdGhlIEZpbGVMaXN0IG9iamVjdFxyXG4gICAgICAgIGNvbnN0IGYgPSBldnQudGFyZ2V0LmZpbGVzWzBdO1xyXG5cclxuICAgICAgICBpZiAoZikge1xyXG4gICAgICAgICAgICBjb25zdCByID0gbmV3IEZpbGVSZWFkZXIoKTtcclxuICAgICAgICAgICAgci5vbmxvYWQgPSAoZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgY29udGVudHMgPSBlLnRhcmdldC5yZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhYmFzZSA9IEpTT04ucGFyc2UoY29udGVudHMpO1xyXG4gICAgICAgICAgICAgICAgREJNUy5zZXREYXRhYmFzZShkYXRhYmFzZSwgc3RhdGUuY2FsbGJhY2spO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICByLnJlYWRBc1RleHQoZik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgVXRpbHMuYWxlcnQoZ2V0TDEwbigndXRpbHMtYmFzZS1maWxlLWxvYWRpbmctZXJyb3InKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBleHBvcnRzLnNhdmVGaWxlID0gKCkgPT4ge1xyXG4gICAgICAgIERCTVMuZ2V0RGF0YWJhc2UoKGVyciwgZGF0YWJhc2UpID0+IHtcclxuICAgICAgICAgICAgaWYgKGVycikgeyBVdGlscy5oYW5kbGVFcnJvcihlcnIpOyByZXR1cm47IH1cclxuICAgICAgICAgICAgZXhwb3J0cy5qc29uMkZpbGUoZGF0YWJhc2UsIGAke0JBU0VfRklMRV9OQU1FfS5qc29uYCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIGV4cG9ydHMuanNvbjJGaWxlID0gKHN0ciwgZmlsZU5hbWUpID0+IHtcclxuICAgICAgICBleHBvcnRzLnN0cjJGaWxlKEpTT04uc3RyaW5naWZ5KHN0ciwgbnVsbCwgJyAgJyksIGZpbGVOYW1lKTtcclxuICAgIH07XHJcblxyXG4gICAgZXhwb3J0cy5zdHIyRmlsZSA9IChzdHIsIGZpbGVOYW1lKSA9PiB7XHJcbiAgICAgICAgY29uc3QgYmxvYiA9IG5ldyBCbG9iKFtzdHJdLCB7XHJcbiAgICAgICAgICAgIHR5cGU6ICd0ZXh0L3BsYWluO2NoYXJzZXQ9dXRmLTgnXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgc2F2ZUFzKGJsb2IsIGZpbGVOYW1lKTtcclxuICAgIH07XHJcblxyXG4gICAgZnVuY3Rpb24gcHJlcHJvY2Vzc0NzdlN0cihzdHIpIHtcclxuICAgICAgICBpZiAoISh0eXBlb2Ygc3RyID09PSAnc3RyaW5nJyB8fCBzdHIgaW5zdGFuY2VvZiBTdHJpbmcpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzdHI7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGxldCByZXN1bHQgPSBzdHIucmVwbGFjZSgvXCIvZywgJ1wiXCInKTtcclxuICAgICAgICBpZiAocmVzdWx0LnNlYXJjaCgvKFwifCx8XFxuKS9nKSA+PSAwKSB7XHJcbiAgICAgICAgICAgIHJlc3VsdCA9IGBcIiR7cmVzdWx0fVwiYDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcclxuICAgIH1cclxuXHJcbiAgICBleHBvcnRzLmFycjJkMkNzdiA9IChhcnIsIGZpbGVOYW1lKSA9PiB7XHJcbiAgICAgICAgY29uc3QgY3N2ID0gYFxcdWZlZmYke2Fyci5tYXAoZGF0YUFycmF5ID0+IGRhdGFBcnJheS5tYXAocHJlcHJvY2Vzc0NzdlN0cikuam9pbignOycpKS5qb2luKCdcXG4nKX1gO1xyXG5cclxuICAgICAgICBjb25zdCBvdXQgPSBuZXcgQmxvYihbY3N2XSwge1xyXG4gICAgICAgICAgICB0eXBlOiAndGV4dC9jc3Y7Y2hhcnNldD11dGYtODsnXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgc2F2ZUFzKG91dCwgZmlsZU5hbWUpO1xyXG4gICAgfTtcclxufSkodGhpcy5GaWxlVXRpbHMgPSB7fSk7XHJcbiIsIi8qQ29weXJpZ2h0IDIwMTUtMjAxNyBUaW1vZmV5IFJlY2hrYWxvdiA8bnRzZGtAeWFuZGV4LnJ1PiwgTWFyaWEgU2lkZWtobWVub3ZhIDxtYXRpbGRhX0BsaXN0LnJ1PlxyXG5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuXHJcbmh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAgICBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbi8qIGVzbGludC1kaXNhYmxlIG5vLXZhcix2YXJzLW9uLXRvcCAqL1xyXG5cclxuKChleHBvcnRzLCBEaWN0aW9uYXJpZXMpID0+IHtcclxuICAgIGNvbnN0IHN0YXRlID0ge307XHJcblxyXG4gICAgc3RhdGUuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcclxuICAgIHN0YXRlLmwxMG5EZWxlZ2F0ZXMgPSBbXTtcclxuICAgIHN0YXRlLmRpY3Rpb25hcmllcyA9IHt9O1xyXG4gICAgc3RhdGUubGFuZyA9IGRlZmF1bHRMYW5nO1xyXG5cclxuICAgIGNvbnN0IGluaXQgPSAoKSA9PiB7XHJcbiAgICAgICAgaWYgKHN0YXRlLmluaXRpYWxpemVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gICAgICAgIGNvbnNvbGUubG9nKG5hdmlnYXRvci5sYW5ndWFnZSk7XHJcblxyXG4gICAgICAgIHN0YXRlLmRpY3Rpb25hcmllcyA9IFIubWFwKHByb2Nlc3NEaWN0aW9uYXJ5LCBEaWN0aW9uYXJpZXMpO1xyXG5cclxuICAgICAgICAvLyAgICB2YXIgbGFuZyA9IChuYXZpZ2F0b3IubGFuZ3VhZ2VzID8gbmF2aWdhdG9yLmxhbmd1YWdlc1swXSA6IG5hdmlnYXRvci5icm93c2VyTGFuZ3VhZ2UpLnNwbGl0KCctJylbMF07XHJcbiAgICAgICAgLy8gICAgdmFyIGxhbmcgPSAncnUnO1xyXG4gICAgICAgIC8vICAgICAgICB2YXIgbGFuZyA9IGRlZmF1bHRMYW5nO1xyXG4gICAgICAgIC8vICAgICAgICBjb25zb2xlLmxvZyhsYW5nKTtcclxuXHJcbiAgICAgICAgaWYgKHN0YXRlLmRpY3Rpb25hcmllc1tkZWZhdWx0TGFuZ10pIHtcclxuICAgICAgICAgICAgc3RhdGUuZGljdCA9IHN0YXRlLmRpY3Rpb25hcmllc1tkZWZhdWx0TGFuZ107XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgc3RhdGUuZGljdCA9IHN0YXRlLmRpY3Rpb25hcmllcy5lbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgc2V0SHRtbExhbmcoZGVmYXVsdExhbmcpO1xyXG4gICAgICAgIGV4cG9ydHMub25MMTBuQ2hhbmdlKGV4cG9ydHMubG9jYWxpemVTdGF0aWMpO1xyXG4gICAgICAgIHN0YXRlLmluaXRpYWxpemVkID0gdHJ1ZTtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIHByb2Nlc3NEaWN0aW9uYXJ5ID0gKGRpY3Rpb25hcnkpID0+IHtcclxuICAgICAgICBjb25zdCBwcm9jZXNzZWREaWN0aW9uYXJ5ID0ge307XHJcbiAgICAgICAgUi50b1BhaXJzKGRpY3Rpb25hcnkpLmZvckVhY2goKFtzZWN0aW9uTmFtZSwgc2VjdGlvbl0pID0+IHtcclxuICAgICAgICAgICAgUi50b1BhaXJzKHNlY3Rpb24pLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgcHJvY2Vzc2VkRGljdGlvbmFyeVtgJHtzZWN0aW9uTmFtZX0tJHtrZXl9YF0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgLy8gICAgICAgIGZvciAoY29uc3Qgc2VjdGlvbk5hbWUgaW4gZGljdGlvbmFyeSkge1xyXG4gICAgICAgIC8vICAgICAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIGRpY3Rpb25hcnlbc2VjdGlvbk5hbWVdKSB7XHJcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgcHJvY2Vzc2VkRGljdGlvbmFyeVtgJHtzZWN0aW9uTmFtZX0tJHtuYW1lfWBdID0gZGljdGlvbmFyeVtzZWN0aW9uTmFtZV1bbmFtZV07XHJcbiAgICAgICAgLy8gICAgICAgICAgICB9XHJcbiAgICAgICAgLy8gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gcHJvY2Vzc2VkRGljdGlvbmFyeTtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIHNldEh0bWxMYW5nID0gbGFuZyA9PiBzZXRBdHRyKGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdodG1sJylbMF0sICdsYW5nJywgbGFuZyk7XHJcblxyXG4gICAgZXhwb3J0cy50b2dnbGVMMTBuID0gKCkgPT4ge1xyXG4gICAgICAgIGlmIChzdGF0ZS5sYW5nID09PSAncnUnKSB7XHJcbiAgICAgICAgICAgIHN0YXRlLmRpY3QgPSBzdGF0ZS5kaWN0aW9uYXJpZXMuZW47XHJcbiAgICAgICAgICAgIHN0YXRlLmxhbmcgPSAnZW4nO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHN0YXRlLmRpY3QgPSBzdGF0ZS5kaWN0aW9uYXJpZXMucnU7XHJcbiAgICAgICAgICAgIHN0YXRlLmxhbmcgPSAncnUnO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzZXRIdG1sTGFuZyhzdGF0ZS5sYW5nKTtcclxuICAgICAgICBzdGF0ZS5sMTBuRGVsZWdhdGVzLmZvckVhY2goKGRlbGVnYXRlKSA9PiB7XHJcbiAgICAgICAgICAgIGRlbGVnYXRlKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIGV4cG9ydHMuZ2V0TGFuZyA9ICgpID0+IHN0YXRlLmxhbmcudG9Mb3dlckNhc2UoKTtcclxuXHJcbiAgICBleHBvcnRzLmZvcm1hdCA9IFIuY3VycnkoKG5hbWVzcGFjZSwgbmFtZSwgYXJncykgPT4gc3RyRm9ybWF0KGV4cG9ydHMuZ2V0KG5hbWVzcGFjZSwgbmFtZSksIGFyZ3MpKTtcclxuXHJcbiAgICBleHBvcnRzLmdldCA9IFIuY3VycnkoKG5hbWVzcGFjZSwgbmFtZSkgPT4gTDEwbi5nZXRWYWx1ZShgJHtuYW1lc3BhY2V9LSR7bmFtZX1gKSk7XHJcblxyXG4gICAgZXhwb3J0cy5nZXRWYWx1ZSA9IChuYW1lKSA9PiB7XHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSBzdGF0ZS5kaWN0W25hbWVdO1xyXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSBjb25zb2xlLmxvZyhgVmFsdWUgaXMgbm90IGZvdW5kOiAke25hbWV9YCk7XHJcbiAgICAgICAgcmV0dXJuIHZhbHVlIHx8IGAke25hbWV9OlJBIFJBLUFILUFILUFIIFJPTUEgUk9NQS1NQSBHQUdBIE9IIExBLUxBYDtcclxuICAgIH07XHJcblxyXG4gICAgZXhwb3J0cy5vbkwxMG5DaGFuZ2UgPSAoZGVsZWdhdGUpID0+IHtcclxuICAgICAgICBzdGF0ZS5sMTBuRGVsZWdhdGVzLnB1c2goZGVsZWdhdGUpO1xyXG4gICAgfTtcclxuXHJcbiAgICBleHBvcnRzLmxvY2FsaXplU3RhdGljID0gKCkgPT4ge1xyXG4gICAgICAgIGluaXQoKTtcclxuICAgICAgICBubDJhcnJheShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbbDEwbi1pZF0nKSkubWFwKGVsID0+IGFkZEVsKGNsZWFyRWwoZWwpLCBtYWtlVGV4dChleHBvcnRzLmdldFZhbHVlKGdldEF0dHIoZWwsICdsMTBuLWlkJykpKSkpO1xyXG4gICAgICAgIG5sMmFycmF5KGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tsMTBuLXBsYWNlaG9sZGVyLWlkXScpKS5tYXAoZWwgPT4gc2V0QXR0cihlbCwgJ3BsYWNlaG9sZGVyJywgZXhwb3J0cy5nZXRWYWx1ZShnZXRBdHRyKGVsLCAnbDEwbi1wbGFjZWhvbGRlci1pZCcpKSkpO1xyXG4gICAgfTtcclxufSkodGhpcy5MMTBuID0ge30sIERpY3Rpb25hcmllcyk7XHJcbiIsIi8qQ29weXJpZ2h0IDIwMTUtMjAxNyBUaW1vZmV5IFJlY2hrYWxvdiA8bnRzZGtAeWFuZGV4LnJ1PiwgTWFyaWEgU2lkZWtobWVub3ZhIDxtYXRpbGRhX0BsaXN0LnJ1PlxyXG5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuXHJcbmh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAgICBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbi8qIGVzbGludC1kaXNhYmxlIG5vLXZhcix2YXJzLW9uLXRvcCAqL1xyXG5cclxuKChleHBvcnRzKSA9PiB7XHJcbiAgICBleHBvcnRzLmluaXRUYWJQYW5lbCA9ICh0YWJDbGF6eiwgY29udGFpbmVyQ2xhenopID0+IHtcclxuICAgICAgICBjb25zdCBjb250YWluZXJzID0gZ2V0RWxzKGNvbnRhaW5lckNsYXp6KTtcclxuXHJcbiAgICAgICAgbGV0IGk7XHJcbiAgICAgICAgZm9yIChpID0gMTsgaSA8IGNvbnRhaW5lcnMubGVuZ3RoOyBpKyspIHsgLy8gZG9uJ3QgaGlkZSAxc3QgZWxlbWVudFxyXG4gICAgICAgICAgICBhZGRDbGFzcyhjb250YWluZXJzW2ldLCAnaGlkZGVuJyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCB0YWJCdXR0b25zID0gZ2V0RWxzKHRhYkNsYXp6KTtcclxuXHJcbiAgICAgICAgYWRkQ2xhc3ModGFiQnV0dG9uc1swXSwgJ2FjdGl2ZScpO1xyXG5cclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGFiQnV0dG9ucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBsaXN0ZW4odGFiQnV0dG9uc1tpXSwgJ2NsaWNrJywgdGFiQnV0dG9uQ2xpY2sodGFiQnV0dG9ucywgY29udGFpbmVycykpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgdmFyIHRhYkJ1dHRvbkNsaWNrID0gKGJ1dHRvbnMsIGNvbnRhaW5lcnMpID0+IChldmVudCkgPT4ge1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnV0dG9ucy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBzZXRDbGFzc0J5Q29uZGl0aW9uKGJ1dHRvbnNbaV0sICdhY3RpdmUnLCBldmVudC50YXJnZXQuaWQgPT09IGJ1dHRvbnNbaV0uaWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbnRhaW5lcnMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgc2V0Q2xhc3NCeUNvbmRpdGlvbihjb250YWluZXJzW2ldLCAnaGlkZGVuJywgYCR7ZXZlbnQudGFyZ2V0LmlkfUNvbnRhaW5lcmAgIT09IGNvbnRhaW5lcnNbaV0uaWQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgZXhwb3J0cy5maWxsU2hvd0l0ZW1TZWxlY3RvciA9IChzZWxlY3RvciwgZGlzcGxheUFycmF5KSA9PiB7XHJcbiAgICAgICAgbGV0IGVsO1xyXG4gICAgICAgIHNldEF0dHIoc2VsZWN0b3IsICdzaXplJywgZGlzcGxheUFycmF5Lmxlbmd0aCk7XHJcbiAgICAgICAgZGlzcGxheUFycmF5LmZvckVhY2goKHZhbHVlKSA9PiB7XHJcbiAgICAgICAgICAgIGVsID0gc2V0UHJvcHMobWFrZUVsKCdvcHRpb24nKSwge1xyXG4gICAgICAgICAgICAgICAgc2VsZWN0ZWQ6IHRydWUsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBzZXRDbGFzc0J5Q29uZGl0aW9uKGVsLCAnaGlkZGVuJywgdmFsdWUuaGlkZGVuKTtcclxuICAgICAgICAgICAgYWRkRWwoc2VsZWN0b3IsIGFkZEVsKGVsLCBtYWtlVGV4dCh2YWx1ZS5uYW1lKSkpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuXHJcbiAgICBleHBvcnRzLmZpbGxTaG93SXRlbVNlbGVjdG9yMiA9IChzZWxlY3Rvciwgb3B0aW9uR3JvdXBzKSA9PiB7XHJcbiAgICAgICAgbGV0IGVsLCBncm91cEVsLCBjb3VudGVyID0gMDtcclxuICAgICAgICBhZGRFbHMoc2VsZWN0b3IsIG9wdGlvbkdyb3Vwcy5tYXAoKGdyb3VwKSA9PiB7XHJcbiAgICAgICAgICAgIGNvdW50ZXIrKztcclxuICAgICAgICAgICAgZ3JvdXBFbCA9IHNldEF0dHIobWFrZUVsKCdvcHRncm91cCcpLCAnbGFiZWwnLCBncm91cC5uYW1lKTtcclxuICAgICAgICAgICAgYWRkRWxzKGdyb3VwRWwsIGdyb3VwLmFycmF5Lm1hcCgodmFsdWUpID0+IHtcclxuICAgICAgICAgICAgICAgIGVsID0gc2V0UHJvcHMobWFrZUVsKCdvcHRpb24nKSwge1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBzZXRDbGFzc0J5Q29uZGl0aW9uKGVsLCAnaGlkZGVuJywgdmFsdWUuaGlkZGVuKTtcclxuICAgICAgICAgICAgICAgIGNvdW50ZXIgKz0gKHZhbHVlLmhpZGRlbiA/IDAgOiAxKTtcclxuICAgICAgICAgICAgICAgIHJldHVybiBhZGRFbChlbCwgbWFrZVRleHQodmFsdWUubmFtZSkpO1xyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgICAgIHJldHVybiBncm91cEVsO1xyXG4gICAgICAgIH0pKTtcclxuICAgICAgICBzZXRBdHRyKHNlbGVjdG9yLCAnc2l6ZScsIGNvdW50ZXIpO1xyXG4gICAgfTtcclxuXHJcbiAgICBleHBvcnRzLnNob3dTZWxlY3RlZEVscyA9IGNsYXNzS2V5ID0+IChldmVudCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGVsID0gZXZlbnQudGFyZ2V0O1xyXG4gICAgICAgIGxldCBlbHMsIGksIGo7XHJcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGVsLm9wdGlvbnMubGVuZ3RoOyBpICs9IDEpIHtcclxuICAgICAgICAgICAgZWxzID0gZ2V0RWxzKGkgKyBjbGFzc0tleSk7XHJcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBlbHMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgICAgICAgIHNldENsYXNzQnlDb25kaXRpb24oZWxzW2pdLCAnaGlkZGVuJywgIWVsLm9wdGlvbnNbaV0uc2VsZWN0ZWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBleHBvcnRzLmluaXRTZWxlY3RvckZpbHRlcnMgPSAoKSA9PiB7XHJcbiAgICAgICAgY29uc3QgZWxlbXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbc2VsZWN0b3ItZmlsdGVyXScpO1xyXG4gICAgICAgIGxldCBlbCwgc2VsO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZWxlbXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgZWwgPSBlbGVtc1tpXTtcclxuICAgICAgICAgICAgc2VsID0gcXVlcnlFbChnZXRBdHRyKGVsLCAnc2VsZWN0b3ItZmlsdGVyJykpO1xyXG4gICAgICAgICAgICBlbC52YWx1ZSA9ICcnO1xyXG4gICAgICAgICAgICBsaXN0ZW4oZWwsICdpbnB1dCcsIGZpbHRlck9wdGlvbnMoc2VsKSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgZmlsdGVyT3B0aW9ucyA9IHNlbCA9PiAoZXZlbnQpID0+IHtcclxuICAgICAgICBsZXQgdmFsID0gZXZlbnQudGFyZ2V0LnZhbHVlO1xyXG4gICAgICAgIGxldCBpLCBvcHQ7XHJcbiAgICAgICAgdmFsID0gQ29tbW9uVXRpbHMuZ2xvYlN0cmluZ1RvUmVnZXgodmFsLnRyaW0oKS50b0xvd2VyQ2FzZSgpKTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc2VsLm9wdGlvbnMubGVuZ3RoOyBpICs9IDEpIHtcclxuICAgICAgICAgICAgb3B0ID0gc2VsLm9wdGlvbnNbaV07XHJcbiAgICAgICAgICAgIGNvbnN0IGlzVmlzaWJsZSA9IG9wdC5pbm5lckhUTUwudG9Mb3dlckNhc2UoKS5zZWFyY2godmFsKSAhPT0gLTE7XHJcbiAgICAgICAgICAgIGlmICghaXNWaXNpYmxlKSB7XHJcbiAgICAgICAgICAgICAgICBvcHQuc2VsZWN0ZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBzZXRDbGFzc0J5Q29uZGl0aW9uKG9wdCwgJ2hpZGRlbicsICFpc1Zpc2libGUpO1xyXG4gICAgICAgICAgICAvLyAgICAgICAgICAgICAgICBzZXRDbGFzc0J5Q29uZGl0aW9uKG9wdCwgXCJoaWRkZW5cIiwgb3B0LmlubmVySFRNTC50b0xvd2VyQ2FzZSgpLnNlYXJjaCh2YWwpID09PSAtMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHNlbC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnY2hhbmdlJykpO1xyXG4gICAgfTtcclxuXHJcbiAgICBleHBvcnRzLmluaXRQYW5lbFRvZ2dsZXJzID0gKCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGVsZW1zID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW3BhbmVsLXRvZ2dsZXJdJyk7XHJcbiAgICAgICAgbGV0IGVsLCBzZWwsIGF0dHI7XHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbGVtcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBlbCA9IGVsZW1zW2ldO1xyXG4gICAgICAgICAgICBhdHRyID0gZ2V0QXR0cihlbCwgJ3BhbmVsLXRvZ2dsZXInKTtcclxuICAgICAgICAgICAgYWRkQ2xhc3MoZWwsICdleHBhbmRlZCcpO1xyXG4gICAgICAgICAgICBzZWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGF0dHIpO1xyXG4gICAgICAgICAgICBpZiAoc2VsID09IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIFV0aWxzLmFsZXJ0KGBQYW5lbCB0b2dnbGVyIGlzIGJyb2tlbjogJHthdHRyfWApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxpc3RlbihlbCwgJ2NsaWNrJywgdG9nZ2xlUGFuZWwoZWwsIHNlbCkpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBcclxuICAgIGV4cG9ydHMuYXR0YWNoUGFuZWxUb2dnbGVyID0gKGhlYWRlciwgY29udGVudCwgY2FsbGJhY2spID0+IHtcclxuICAgICAgICBhZGRDbGFzcyhoZWFkZXIsICdleHBhbmRlZCcpO1xyXG4gICAgICAgIGxpc3RlbihoZWFkZXIsICdjbGljaycsIChldmVudCkgPT4ge1xyXG4gICAgICAgICAgICBpZihjYWxsYmFjaykge1xyXG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXZlbnQsICgpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICB0b2dnbGVQYW5lbChoZWFkZXIsIGNvbnRlbnQpKGV2ZW50KTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdG9nZ2xlUGFuZWwoaGVhZGVyLCBjb250ZW50KShldmVudCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH07XHJcblxyXG4gICAgdmFyIHRvZ2dsZVBhbmVsID0gKGVsLCBzZWwpID0+IChldmVudCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGlzRXhwYW5kZWQgPSBoYXNDbGFzcyhlbCwgJ2V4cGFuZGVkJyk7XHJcbiAgICAgICAgcmVtb3ZlQ2xhc3NlcyhlbCwgWydleHBhbmRlZCcsICdjb2xsYXBzZWQnXSk7XHJcbiAgICAgICAgYWRkQ2xhc3MoZWwsIGlzRXhwYW5kZWQgPyAnY29sbGFwc2VkJyA6ICdleHBhbmRlZCcpO1xyXG4gICAgICAgIHRvZ2dsZUNsYXNzKHNlbCwgJ2hpZGRlbicpO1xyXG4gICAgfTtcclxuICAgIFxyXG4gICAgZXhwb3J0cy5tYWtlRXZlbnRUaW1lUGlja2VyID0gKG9wdHMpID0+IHtcclxuICAgICAgICBjb25zdCBpbnB1dCA9IG1ha2VFbCgnaW5wdXQnKTtcclxuICAgICAgICBSLmFwKFthZGRDbGFzcyhpbnB1dCldLCBvcHRzLmV4dHJhQ2xhc3Nlcyk7XHJcbiAgICAgICAgYWRkQ2xhc3MoaW5wdXQsICdldmVudFRpbWUnKTtcclxuICAgICAgICBpbnB1dC52YWx1ZSA9IG9wdHMuZXZlbnRUaW1lO1xyXG5cclxuICAgICAgICBpbnB1dC5ldmVudEluZGV4ID0gb3B0cy5pbmRleDtcclxuXHJcbiAgICAgICAgY29uc3QgcGlja2VyT3B0cyA9IHtcclxuICAgICAgICAgICAgbGFuZzogTDEwbi5nZXRMYW5nKCksXHJcbiAgICAgICAgICAgIG1hc2s6IHRydWUsXHJcbiAgICAgICAgICAgIHN0YXJ0RGF0ZTogbmV3IERhdGUob3B0cy5wcmVHYW1lRGF0ZSksXHJcbiAgICAgICAgICAgIGVuZERhdGU6IG5ldyBEYXRlKG9wdHMuZGF0ZSksXHJcbiAgICAgICAgICAgIG9uQ2hhbmdlRGF0ZVRpbWU6IG9wdHMub25DaGFuZ2VEYXRlVGltZUNyZWF0b3IoaW5wdXQpLFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGlmIChvcHRzLmV2ZW50VGltZSAhPT0gJycpIHtcclxuICAgICAgICAgICAgcGlja2VyT3B0cy52YWx1ZSA9IG9wdHMuZXZlbnRUaW1lO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHBpY2tlck9wdHMudmFsdWUgPSBvcHRzLmRhdGU7XHJcbiAgICAgICAgICAgIGFkZENsYXNzKGlucHV0LCAnZGVmYXVsdERhdGUnKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGpRdWVyeShpbnB1dCkuZGF0ZXRpbWVwaWNrZXIocGlja2VyT3B0cyk7XHJcbiAgICAgICAgcmV0dXJuIGlucHV0O1xyXG4gICAgfTtcclxuXHJcbiAgICAvLyBidWcgYWJvdXQgc2V0dGluZyAwOTAwIHllYXJzIGluIEJyYWF2b3MgZ2FtZSBpcyBldmVudCBkYXRlLiBGaXhlZCBpbiBwcm9kdWN0aW9uLlxyXG4gICAgLy8gIGV4cG9ydHMubWFrZUV2ZW50VGltZVBpY2tlciA9IGZ1bmN0aW9uIChvcHRzKSB7XHJcbiAgICAvLyAgICAgIHZhciBpbnB1dCA9IG1ha2VFbChcImlucHV0XCIpO1xyXG4gICAgLy8gICAgICBSLmFwKFthZGRDbGFzcyhpbnB1dCldLCBvcHRzLmV4dHJhQ2xhc3Nlcyk7XHJcbiAgICAvLyAgICAgIGFkZENsYXNzKGlucHV0LCBcImV2ZW50VGltZVwiKTtcclxuICAgIC8vICAgICAgaW5wdXQudmFsdWUgPSBvcHRzLmV2ZW50VGltZTtcclxuICAgIC8vXHJcbiAgICAvLyAgICAgIGlucHV0LmV2ZW50SW5kZXggPSBvcHRzLmluZGV4O1xyXG4gICAgLy9cclxuICAgIC8vICAgICAgdmFyIHBpY2tlck9wdHMgPSB7XHJcbiAgICAvLyAgICAgICAgICBsYW5nIDogTDEwbi5nZXRMYW5nKCksXHJcbiAgICAvLyAgICAgICAgICBtYXNrIDogdHJ1ZSxcclxuICAgIC8vICAgICAgICAgIHN0YXJ0RGF0ZSA6IG5ldyBEYXRlKG9wdHMucHJlR2FtZURhdGUpLFxyXG4gICAgLy8gICAgICAgICAgZW5kRGF0ZSA6IG5ldyBEYXRlKG9wdHMuZGF0ZSksXHJcbiAgICAvLyAgICAgICAgICBvbkNoYW5nZURhdGVUaW1lIDogb3B0cy5vbkNoYW5nZURhdGVUaW1lQ3JlYXRvcihpbnB1dCksXHJcbiAgICAvLyAgICAgIH07XHJcbiAgICAvL1xyXG4gICAgLy8gICAgICB2YXIgcGlja2VyID0galF1ZXJ5KGlucHV0KS5kYXRldGltZXBpY2tlcihwaWNrZXJPcHRzKTtcclxuICAgIC8vXHJcbiAgICAvLyAgICAgIHZhciB2YWx1ZTtcclxuICAgIC8vICAgICAgaWYgKG9wdHMuZXZlbnRUaW1lICE9PSBcIlwiKSB7XHJcbiAgICAvLyAgICAgICAgICB2YWx1ZSA9IG5ldyBEYXRlKG9wdHMuZXZlbnRUaW1lKTtcclxuICAgIC8vICAgICAgfSBlbHNlIHtcclxuICAgIC8vICAgICAgICAgIHZhbHVlID0gb3B0cy5kYXRlO1xyXG4gICAgLy8gICAgICAgICAgYWRkQ2xhc3MoaW5wdXQsIFwiZGVmYXVsdERhdGVcIik7XHJcbiAgICAvLyAgICAgIH1cclxuICAgIC8vXHJcbiAgICAvLyAgICAgIHBpY2tlci52YWx1ZSA9IHZhbHVlO1xyXG4gICAgLy9cclxuICAgIC8vXHJcbiAgICAvLyAgICAgIHJldHVybiBpbnB1dDtcclxuICAgIC8vICB9O1xyXG5cclxuICAgIGV4cG9ydHMucmVzaXplVGV4dGFyZWEgPSAoZXYpID0+IHtcclxuICAgICAgICBjb25zdCB0aGF0ID0gZXYudGFyZ2V0O1xyXG4gICAgICAgIHRoYXQuc3R5bGUuaGVpZ2h0ID0gJzI0cHgnO1xyXG4gICAgICAgIHRoYXQuc3R5bGUuaGVpZ2h0ID0gYCR7dGhhdC5zY3JvbGxIZWlnaHQgKyAxMn1weGA7XHJcbiAgICB9O1xyXG5cclxuICAgIGV4cG9ydHMucmVzaXplVGV4dGFyZWEyID0gKHRoYXQpID0+IHtcclxuICAgICAgICB0aGF0LnN0eWxlLmhlaWdodCA9ICcyNHB4JztcclxuICAgICAgICB0aGF0LnN0eWxlLmhlaWdodCA9IGAke3RoYXQuc2Nyb2xsSGVpZ2h0ICsgMTJ9cHhgO1xyXG4gICAgfTtcclxuXHJcbiAgICBleHBvcnRzLm1ha2VBZGFwdGF0aW9uVGltZUlucHV0ID0gKHN0b3J5TmFtZSwgZXZlbnQsIGNoYXJhY3Rlck5hbWUsIGlzRWRpdGFibGUpID0+IHtcclxuICAgICAgICBjb25zdCBpbnB1dCA9IG1ha2VFbCgnaW5wdXQnKTtcclxuICAgICAgICBzZXRDbGFzc0J5Q29uZGl0aW9uKGlucHV0LCAnbm90RWRpdGFibGUnLCAhaXNFZGl0YWJsZSk7XHJcbiAgICAgICAgYWRkQ2xhc3MoaW5wdXQsICdhZGFwdGF0aW9uVGltZUlucHV0Jyk7XHJcbiAgICAgICAgaW5wdXQudmFsdWUgPSBldmVudC5jaGFyYWN0ZXJzW2NoYXJhY3Rlck5hbWVdLnRpbWU7XHJcbiAgICAgICAgaW5wdXQuZGF0YUtleSA9IEpTT04uc3RyaW5naWZ5KFtzdG9yeU5hbWUsIGV2ZW50LmluZGV4LCBjaGFyYWN0ZXJOYW1lXSk7XHJcbiAgICAgICAgbGlzdGVuKGlucHV0LCAnY2hhbmdlJywgb25DaGFuZ2VQZXJzb25hbFRpbWVEZWxlZ2F0ZSk7XHJcbiAgICAgICAgcmV0dXJuIGlucHV0O1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgb25DaGFuZ2VQZXJzb25hbFRpbWVEZWxlZ2F0ZSA9IChldmVudCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGRhdGFLZXkgPSBKU09OLnBhcnNlKGV2ZW50LnRhcmdldC5kYXRhS2V5KTtcclxuICAgICAgICBjb25zdCB0aW1lID0gZXZlbnQudGFyZ2V0LnZhbHVlO1xyXG4gICAgICAgIERCTVMuc2V0RXZlbnRBZGFwdGF0aW9uUHJvcGVydHkoZGF0YUtleVswXSwgZGF0YUtleVsxXSwgZGF0YUtleVsyXSwgJ3RpbWUnLCB0aW1lLCBVdGlscy5wcm9jZXNzRXJyb3IoKSk7XHJcbiAgICB9O1xyXG5cclxuICAgIGV4cG9ydHMubWFrZUFkYXB0YXRpb25SZWFkeUlucHV0ID0gKHN0b3J5TmFtZSwgZXZlbnQsIGNoYXJhY3Rlck5hbWUsIGlzRWRpdGFibGUpID0+IHtcclxuICAgICAgICBjb25zdCBkaXYgPSBtYWtlRWwoJ2RpdicpO1xyXG4gICAgICAgIGNvbnN0IGlucHV0ID0gbWFrZUVsKCdpbnB1dCcpO1xyXG4gICAgICAgIHNldENsYXNzQnlDb25kaXRpb24oaW5wdXQsICdub3RFZGl0YWJsZScsICFpc0VkaXRhYmxlKTtcclxuICAgICAgICBpbnB1dC50eXBlID0gJ2NoZWNrYm94JztcclxuICAgICAgICBpbnB1dC5jaGVja2VkID0gZXZlbnQuY2hhcmFjdGVyc1tjaGFyYWN0ZXJOYW1lXS5yZWFkeTtcclxuICAgICAgICBpbnB1dC5kYXRhS2V5ID0gSlNPTi5zdHJpbmdpZnkoW3N0b3J5TmFtZSwgZXZlbnQuaW5kZXgsIGNoYXJhY3Rlck5hbWVdKTtcclxuICAgICAgICBpbnB1dC5pZCA9IGAke2V2ZW50LmluZGV4fS0ke3N0b3J5TmFtZX0tJHtjaGFyYWN0ZXJOYW1lfWA7XHJcbiAgICAgICAgbGlzdGVuKGlucHV0LCAnY2hhbmdlJywgb25DaGFuZ2VSZWFkeVN0YXR1cyk7XHJcbiAgICAgICAgYWRkRWwoZGl2LCBpbnB1dCk7XHJcblxyXG4gICAgICAgIGFkZEVsKGRpdiwgc2V0QXR0cihhZGRFbChtYWtlRWwoJ2xhYmVsJyksIG1ha2VUZXh0KGNvbnN0TDEwbihDb25zdGFudHMuZmluaXNoZWRUZXh0KSkpLCAnZm9yJywgaW5wdXQuaWQpKTtcclxuICAgICAgICByZXR1cm4gZGl2O1xyXG4gICAgfTtcclxuXHJcbiAgICB2YXIgb25DaGFuZ2VSZWFkeVN0YXR1cyA9IChldmVudCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGRhdGFLZXkgPSBKU09OLnBhcnNlKGV2ZW50LnRhcmdldC5kYXRhS2V5KTtcclxuICAgICAgICBjb25zdCB2YWx1ZSA9IGV2ZW50LnRhcmdldC5jaGVja2VkO1xyXG4gICAgICAgIERCTVMuc2V0RXZlbnRBZGFwdGF0aW9uUHJvcGVydHkoZGF0YUtleVswXSwgZGF0YUtleVsxXSwgZGF0YUtleVsyXSwgJ3JlYWR5JywgdmFsdWUsIFV0aWxzLnByb2Nlc3NFcnJvcigpKTtcclxuICAgIH07XHJcblxyXG4gICAgZXhwb3J0cy5tYWtlUGFuZWxDb3JlID0gKHRpdGxlLCBjb250ZW50KSA9PiB7XHJcbiAgICAgICAgY29uc3QgcGFuZWwgPSBhZGRDbGFzc2VzKG1ha2VFbCgnZGl2JyksIFsncGFuZWwnLCAncGFuZWwtZGVmYXVsdCddKTtcclxuICAgICAgICBjb25zdCBoMyA9IGFkZENsYXNzKGFkZEVsKG1ha2VFbCgnaDMnKSwgdGl0bGUpLCAncGFuZWwtdGl0bGUnKTtcclxuICAgICAgICBjb25zdCBhID0gc2V0QXR0cihtYWtlRWwoJ2EnKSwgJ2hyZWYnLCAnIy8nKTtcclxuICAgICAgICBzZXRBdHRyKGEsICdwYW5lbC10b2dnbGVyJywgJycpO1xyXG4gICAgICAgIGNvbnN0IGhlYWREaXYgPSBhZGRDbGFzcyhtYWtlRWwoJ2RpdicpLCAncGFuZWwtaGVhZGluZycpO1xyXG4gICAgICAgIGFkZEVsKHBhbmVsLCBhZGRFbChoZWFkRGl2LCBhZGRFbChhLCBoMykpKTtcclxuICAgICAgICBjb25zdCBjb250ZW50RGl2ID0gYWRkQ2xhc3MobWFrZUVsKCdkaXYnKSwgJ3BhbmVsLWJvZHknKTtcclxuICAgICAgICBhZGRFbChwYW5lbCwgYWRkRWwoY29udGVudERpdiwgY29udGVudCkpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIHBhbmVsLFxyXG4gICAgICAgICAgICBjb250ZW50RGl2LFxyXG4gICAgICAgICAgICBhXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcblxyXG4gICAgZXhwb3J0cy5tYWtlUHJvZmlsZVRhYmxlID0gKHByb2ZpbGVTdHJ1Y3R1cmUsIHByb2ZpbGUpID0+IHtcclxuICAgICAgICBsZXQgdmFsdWU7XHJcbiAgICAgICAgY29uc3QgcHJvZmlsZURpdiA9IGFkZEVscyhtYWtlRWwoJ3Rib2R5JyksIHByb2ZpbGVTdHJ1Y3R1cmUuZmlsdGVyKGVsZW1lbnQgPT4gZWxlbWVudC5kb0V4cG9ydCkubWFwKChlbGVtZW50KSA9PiB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoZWxlbWVudC50eXBlKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ3RleHQnOlxyXG4gICAgICAgICAgICAgICAgdmFsdWUgPSBhZGRDbGFzcyhtYWtlRWwoJ3NwYW4nKSwgJ2JyaWVmaW5nVGV4dFNwYW4nKTtcclxuICAgICAgICAgICAgICAgIGFkZEVsKHZhbHVlLCBtYWtlVGV4dChwcm9maWxlW2VsZW1lbnQubmFtZV0pKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdlbnVtJzpcclxuICAgICAgICAgICAgY2FzZSAnbXVsdGlFbnVtJzpcclxuICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcclxuICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcclxuICAgICAgICAgICAgICAgIHZhbHVlID0gbWFrZVRleHQocHJvZmlsZVtlbGVtZW50Lm5hbWVdKTtcclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlICdjaGVja2JveCc6XHJcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG1ha2VUZXh0KGNvbnN0TDEwbihDb25zdGFudHNbcHJvZmlsZVtlbGVtZW50Lm5hbWVdXSkpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgdHlwZSAke2VsZW1lbnQudHlwZX1gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZXhwb3J0cy5tYWtlVGFibGVSb3cobWFrZVRleHQoZWxlbWVudC5uYW1lKSwgdmFsdWUpO1xyXG4gICAgICAgIH0pKTtcclxuICAgICAgICByZXR1cm4gYWRkRWwoYWRkQ2xhc3NlcyhtYWtlRWwoJ3RhYmxlJyksIFsndGFibGUnLCAndGFibGUtc3RyaXBlZCddKSwgcHJvZmlsZURpdik7XHJcbiAgICB9O1xyXG5cclxuICAgIGV4cG9ydHMubWFrZVRhYmxlUm93ID0gKGNvbDEsIGNvbDIpID0+IGFkZEVscyhtYWtlRWwoJ3RyJyksIFthZGRFbChtYWtlRWwoJ3RkJyksIGNvbDEpLCBhZGRFbChtYWtlRWwoJ3RkJyksIGNvbDIpXSk7XHJcbn0pKHRoaXMuVUkgPSB7fSk7XHJcbiIsIi8qQ29weXJpZ2h0IDIwMTUtMjAxNyBUaW1vZmV5IFJlY2hrYWxvdiA8bnRzZGtAeWFuZGV4LnJ1PiwgTWFyaWEgU2lkZWtobWVub3ZhIDxtYXRpbGRhX0BsaXN0LnJ1PlxyXG5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuXHJcbmh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAgICBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbi8vIFRPRE8gbmVlZCB0byBsaW50IHV0aWxzIHdpdGggTklNUyBmaXhlc1xyXG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xyXG5cclxuY29uc3Qgc3RyRm9ybWF0ID0gUi5jdXJyeShDb21tb25VdGlscy5zdHJGb3JtYXQpO1xyXG5cclxuZnVuY3Rpb24gZ2V0TDEwbihrZXkpIHtcclxuICAgIHJldHVybiBMMTBuLmdldFZhbHVlKGtleSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNvbnN0TDEwbihrZXkpIHtcclxuICAgIHJldHVybiBMMTBuLmdldFZhbHVlKGBjb25zdGFudC0ke2tleX1gKTtcclxufVxyXG5cclxuZnVuY3Rpb24gaXNFbXB0eShvYmopIHtcclxuICAgIHJldHVybiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqKS5sZW5ndGggPT09IDApO1xyXG59XHJcblxyXG5jb25zdCBhZGRDbGFzcyA9IFIuY3VycnkoKG8sIGMpID0+IHtcclxuICAgIGNvbnN0IHJlID0gbmV3IFJlZ0V4cChgKF58XFxcXHMpJHtjfShcXFxcc3wkKWAsICdnJyk7XHJcbiAgICBpZiAocmUudGVzdChvLmNsYXNzTmFtZSkpIHJldHVybiBvO1xyXG4gICAgby5jbGFzc05hbWUgPSAoYCR7by5jbGFzc05hbWV9ICR7Y31gKS5yZXBsYWNlKC9cXHMrL2csICcgJykucmVwbGFjZSgvKF4gfCAkKS9nLCAnJyk7XHJcbiAgICByZXR1cm4gbztcclxufSk7XHJcblxyXG5jb25zdCBhZGRDbGFzc2VzID0gUi5jdXJyeSgobywgYykgPT4ge1xyXG4gICAgUi5hcChbYWRkQ2xhc3MobyldLCBjKTtcclxuICAgIHJldHVybiBvO1xyXG59KTtcclxuXHJcbmNvbnN0IHJBZGRDbGFzcyA9IFIuY3VycnkoKGMsIG8pID0+IGFkZENsYXNzKG8sIGMpKTtcclxuXHJcblxyXG5jb25zdCBoYXNDbGFzcyA9IFIuY3VycnkoKG8sIGMpID0+IHtcclxuICAgIGNvbnN0IHJlID0gbmV3IFJlZ0V4cChgKF58XFxcXHMpJHtjfShcXFxcc3wkKWAsICdnJyk7XHJcbiAgICByZXR1cm4gKHJlLnRlc3Qoby5jbGFzc05hbWUpKTtcclxufSk7XHJcblxyXG5jb25zdCByZW1vdmVDbGFzcyA9IFIuY3VycnkoKG8sIGMpID0+IHtcclxuICAgIGNvbnN0IHJlID0gbmV3IFJlZ0V4cChgKF58XFxcXHMpJHtjfShcXFxcc3wkKWAsICdnJyk7XHJcbiAgICBvLmNsYXNzTmFtZSA9IG8uY2xhc3NOYW1lLnJlcGxhY2UocmUsICckMScpLnJlcGxhY2UoL1xccysvZywgJyAnKS5yZXBsYWNlKC8oXiB8ICQpL2csICcnKTtcclxuICAgIHJldHVybiBvO1xyXG59KTtcclxuXHJcbmNvbnN0IHJlbW92ZUNsYXNzZXMgPSBSLmN1cnJ5KChvLCBjKSA9PiB7XHJcbiAgICBSLmFwKFtyZW1vdmVDbGFzcyhvKV0sIGMpO1xyXG4gICAgcmV0dXJuIG87XHJcbn0pO1xyXG5cclxuY29uc3QgdG9nZ2xlQ2xhc3MgPSBSLmN1cnJ5KChvLCBjKSA9PiB7XHJcbiAgICBpZiAoaGFzQ2xhc3MobywgYykpIHtcclxuICAgICAgICByZW1vdmVDbGFzcyhvLCBjKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgYWRkQ2xhc3MobywgYyk7XHJcbiAgICB9XHJcbn0pO1xyXG5cclxuZnVuY3Rpb24gc2V0Q2xhc3NCeUNvbmRpdGlvbihvLCBjLCBjb25kaXRpb24pIHtcclxuICAgIGlmIChjb25kaXRpb24pIHtcclxuICAgICAgICBhZGRDbGFzcyhvLCBjKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmVtb3ZlQ2xhc3MobywgYyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbztcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0RWwoaWQpIHtcclxuICAgIHJldHVybiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHF1ZXJ5RWwoc2VsKSB7XHJcbiAgICByZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWwpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBxdWVyeUVscyhzZWwpIHtcclxuICAgIHJldHVybiBubDJhcnJheShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbCkpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBxdWVyeUVsRWwoZWwsIHNlbCkge1xyXG4gICAgcmV0dXJuIGVsLnF1ZXJ5U2VsZWN0b3Ioc2VsKTtcclxufVxyXG5cclxuZnVuY3Rpb24gcXVlcnlFbEVscyhlbCwgc2VsKSB7XHJcbiAgICByZXR1cm4gbmwyYXJyYXkoZWwucXVlcnlTZWxlY3RvckFsbChzZWwpKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2V0RWxzKGNsYXp6KSB7XHJcbiAgICByZXR1cm4gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShjbGF6eik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIG1ha2VFbChlbFRhZykge1xyXG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoZWxUYWcpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBtYWtlVGV4dCh0ZXh0KSB7XHJcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dCk7XHJcbn1cclxuXHJcbmNvbnN0IGFkZEVsID0gUi5jdXJyeSgocGFyZW50LCBjaGlsZCkgPT4ge1xyXG4gICAgcGFyZW50LmFwcGVuZENoaWxkKGNoaWxkKTtcclxuICAgIHJldHVybiBwYXJlbnQ7XHJcbn0pO1xyXG5jb25zdCBhZGRFbHMgPSBSLmN1cnJ5KChwYXJlbnQsIGNoaWxkcmVuKSA9PiB7XHJcbiAgICBSLmFwKFthZGRFbChwYXJlbnQpXSwgY2hpbGRyZW4pO1xyXG4gICAgcmV0dXJuIHBhcmVudDtcclxufSk7XHJcblxyXG5jb25zdCBtYWtlT3B0ID0gZnVuY3Rpb24gKGxhYmVsKSB7XHJcbiAgICBjb25zdCBvcHRpb24gPSBtYWtlRWwoJ29wdGlvbicpO1xyXG4gICAgYWRkRWwob3B0aW9uLCAobWFrZVRleHQobGFiZWwpKSk7XHJcbiAgICByZXR1cm4gb3B0aW9uO1xyXG59O1xyXG5cclxuY29uc3QgckFkZEVsID0gUi5jdXJyeSgoY2hpbGQsIHBhcmVudCkgPT4ge1xyXG4gICAgcGFyZW50LmFwcGVuZENoaWxkKGNoaWxkKTtcclxuICAgIHJldHVybiBwYXJlbnQ7XHJcbn0pO1xyXG5cclxuXHJcbmNvbnN0IHNldEF0dHIgPSBSLmN1cnJ5KChlbCwgbmFtZSwgdmFsdWUpID0+IHtcclxuICAgIGVsLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSk7XHJcbiAgICByZXR1cm4gZWw7XHJcbn0pO1xyXG5cclxuY29uc3Qgc2V0U3R5bGUgPSBSLmN1cnJ5KChlbCwgbmFtZSwgdmFsdWUpID0+IHtcclxuICAgIGVsLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbHVlKTtcclxuICAgIHJldHVybiBlbDtcclxufSk7XHJcblxyXG5jb25zdCBzZXRJbXBvcnRhbnRTdHlsZSA9IFIuY3VycnkoKGVsLCBuYW1lLCB2YWx1ZSkgPT4ge1xyXG4gICAgZWwuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgdmFsdWUsICdpbXBvcnRhbnQnKTtcclxuICAgIHJldHVybiBlbDtcclxufSk7XHJcblxyXG5mdW5jdGlvbiBkZWxBdHRyKGVsLCBuYW1lKSB7XHJcbiAgICBlbC5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XHJcbiAgICByZXR1cm4gZWw7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdldEF0dHIoZWwsIG5hbWUpIHtcclxuICAgIHJldHVybiBlbC5nZXRBdHRyaWJ1dGUobmFtZSk7XHJcbn1cclxuXHJcbmNvbnN0IHNldFByb3AgPSBSLmN1cnJ5KChlbCwga2V5LCB2YWx1ZSkgPT4ge1xyXG4gICAgZWxba2V5XSA9IHZhbHVlO1xyXG4gICAgcmV0dXJuIGVsO1xyXG59KTtcclxuXHJcbmNvbnN0IHNldFByb3BzID0gUi5jdXJyeSgoZWwsIG1hcCkgPT4ge1xyXG4gICAgZm9yIChjb25zdCBrZXkgaW4gbWFwKSB7XHJcbiAgICAgICAgc2V0UHJvcChlbCwga2V5LCBtYXBba2V5XSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZWw7XHJcbn0pO1xyXG5cclxuZnVuY3Rpb24gY2xlYXJFbChlbCkge1xyXG4gICAgVXRpbHMucmVtb3ZlQ2hpbGRyZW4oZWwpO1xyXG4gICAgcmV0dXJuIGVsO1xyXG59XHJcblxyXG5mdW5jdGlvbiBwYXNzRWxzKHNyYywgZHN0KSB7XHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNyYy5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGFkZEVsKGRzdCwgc3JjLmNoaWxkcmVuW2ldKTtcclxuICAgIH1cclxufVxyXG5cclxuY29uc3QgbGlzdGVuID0gUi5jdXJyeSgoZWwsIGV2ZW50LCBsaXN0ZW5lcikgPT4ge1xyXG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIpO1xyXG4gICAgcmV0dXJuIGVsO1xyXG59KTtcclxuXHJcbmNvbnN0IGxpc3Rlbk9uRW50ZXIgPSBSLmN1cnJ5KChlbCwgY2FsbGJhY2spID0+IHtcclxuICAgIGxpc3RlbihlbCwgJ2tleWRvd24nLCAoZSkgPT4ge1xyXG4gICAgICAgIGlmIChlLmtleUNvZGUgPT09IDEzKSB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn0pO1xyXG5cclxuY29uc3QgZmlsbFNlbGVjdG9yID0gUi5jdXJyeSgoc2VsLCBkYXRhKSA9PiBhZGRFbHMoc2VsLCBkYXRhLm1hcCgoaXRlbSkgPT4ge1xyXG4gICAgY29uc3Qgb3B0ID0gbWFrZUVsKCdvcHRpb24nKTtcclxuICAgIGFkZEVsKG9wdCwgbWFrZVRleHQoaXRlbS5uYW1lKSk7XHJcbiAgICBpZiAoaXRlbS52YWx1ZSAhPT0gdW5kZWZpbmVkKSB7IG9wdC52YWx1ZSA9IGl0ZW0udmFsdWU7IH1cclxuICAgIGlmIChpdGVtLnNlbGVjdGVkICE9PSB1bmRlZmluZWQpIHsgb3B0LnNlbGVjdGVkID0gdHJ1ZTsgfVxyXG4gICAgaWYgKGl0ZW0uY2xhc3NOYW1lICE9PSB1bmRlZmluZWQpIHsgYWRkQ2xhc3Mob3B0LCBpdGVtLmNsYXNzTmFtZSk7IH1cclxuICAgIHJldHVybiBvcHQ7XHJcbn0pKSk7XHJcblxyXG5mdW5jdGlvbiBubDJhcnJheShub2RlTGlzdCkge1xyXG4gICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG5vZGVMaXN0KTtcclxufVxyXG5cclxuY29uc3QgcmVtYXBQcm9wcyA9IFIuY3VycnkoKG91dEtleXMsIHBpY2tLZXlzLCBvYmopID0+IFIuY29tcG9zZShSLnppcE9iaihvdXRLZXlzKSwgUi52YWx1ZXMsIFIucGljayhwaWNrS2V5cykpKG9iaikpO1xyXG5cclxuY29uc3QgcmVtYXBQcm9wczRTZWxlY3QyID0gcmVtYXBQcm9wcyhbJ2lkJywgJ3RleHQnXSwgWyd2YWx1ZScsICdkaXNwbGF5TmFtZSddKTtcclxuY29uc3QgcmVtYXBQcm9wczRTZWxlY3QgPSByZW1hcFByb3BzKFsndmFsdWUnLCAnbmFtZSddLCBbJ3ZhbHVlJywgJ2Rpc3BsYXlOYW1lJ10pO1xyXG5cclxuY29uc3QgZ2V0U2VsZWN0MkRhdGFDb21tb24gPSBSLmN1cnJ5KChwcmVwYXJhdG9yLCBvYmopID0+IFIuY29tcG9zZShSLnppcE9iaihbJ2RhdGEnXSksIFIuYXBwZW5kKFIuX18sIFtdKSwgUi5tYXAocHJlcGFyYXRvcikpKG9iaikpO1xyXG5cclxuY29uc3QgZ2V0U2VsZWN0MkRhdGEgPSBnZXRTZWxlY3QyRGF0YUNvbW1vbihyZW1hcFByb3BzNFNlbGVjdDIpO1xyXG5cclxuY29uc3QgbWFrZVNlbGVjdDJPcHQgPSBSLmNvbXBvc2UoUi56aXBPYmooWydpZCcsICd0ZXh0J10pLCBSLnJlcGVhdChSLl9fLCAyKSk7XHJcbmNvbnN0IGFycjJTZWxlY3QyID0gUi5jb21wb3NlKFIuYXNzb2MoJ2RhdGEnLCBSLl9fLCB7fSksIFIubWFwKG1ha2VTZWxlY3QyT3B0KSk7XHJcbmNvbnN0IGFycjJTZWxlY3QgPSBSLm1hcChSLmNvbXBvc2UoUi56aXBPYmooWyd2YWx1ZScsICduYW1lJ10pLCBSLnJlcGVhdChSLl9fLCAyKSkpO1xyXG5jb25zdCBjb25zdEFycjJTZWxlY3QgPSBSLm1hcChSLmNvbXBvc2UoUi56aXBPYmooWyd2YWx1ZScsICduYW1lJ10pLCBuYW1lID0+IFtuYW1lLCBjb25zdEwxMG4obmFtZSldKSk7XHJcblxyXG5jb25zdCBnZXRTZWxlY3RlZFJhZGlvID0gZnVuY3Rpb24gKHF1ZXJ5KSB7XHJcbiAgICBjb25zdCBlbHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHF1ZXJ5KTtcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZWxzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGVsc1tpXS5jaGVja2VkID09PSB0cnVlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBlbHNbaV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn07XHJcblxyXG5jb25zdCBkZWJ1Z0ludGVyY2VwdG9yID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKEpTT04uc3RyaW5naWZ5KGFyZ3VtZW50c1swXSkpO1xyXG4gICAgICAgIGNhbGxiYWNrKC4uLmFyZ3VtZW50cyk7XHJcbiAgICB9O1xyXG59O1xyXG5cclxuY29uc3QgVXRpbHMgPSB7fTtcclxuXHJcbi8qKiBvcHRzXHJcbiAgICB0b29sdGlwIC0gYWRkIHRvb2x0aXAgdG8gYnV0dG9uLCB1c2VkIGZvciBpY29uaWMgYnV0dG9uc1xyXG4gICAgaWQgLSBzZXQgYnV0dG9uIGlkXHJcbiAgICBtYWluUGFnZSAtIGVuYWJsZSB2aWV3IGFzIGZpcnN0IHBhZ2VcclxuICAgIHRvZ2dsZSAtIHRvZ2dsZSBjb250ZW50LCBhc3NvY2lhdGVkIHdpdGggYnV0dG9uXHJcbiovXHJcblV0aWxzLmFkZFZpZXcgPSBmdW5jdGlvbiAoY29udGFpbmVycywgbmFtZSwgdmlldywgb3B0czIpIHtcclxuICAgIGNvbnN0IG9wdHMgPSBvcHRzMiB8fCB7fTtcclxuICAgIHZpZXcuaW5pdCgpO1xyXG4gICAgY29uc3QgYnV0dG9uQ2xhc3MgPSAnbmF2aWdhdGlvbi1idXR0b24nO1xyXG4gICAgY29udGFpbmVycy5yb290LnZpZXdzW25hbWVdID0gdmlldztcclxuICAgIGNvbnN0IGJ1dHRvbiA9IG1ha2VFbCgnYnV0dG9uJyk7XHJcbiAgICBmdW5jdGlvbiBkZWxlZ2F0ZSgpIHtcclxuICAgICAgICAkKGJ1dHRvbikuYXR0cignZGF0YS1vcmlnaW5hbC10aXRsZScsIEwxMG4uZ2V0VmFsdWUoYGhlYWRlci0ke25hbWV9YCkpO1xyXG4gICAgfVxyXG4gICAgaWYgKG9wdHMudG9vbHRpcCkge1xyXG4gICAgICAgIEwxMG4ub25MMTBuQ2hhbmdlKGRlbGVnYXRlKTtcclxuICAgICAgICAkKGJ1dHRvbikudG9vbHRpcCh7XHJcbiAgICAgICAgICAgIHRpdGxlOiBMMTBuLmdldFZhbHVlKGBoZWFkZXItJHtuYW1lfWApLFxyXG4gICAgICAgICAgICBwbGFjZW1lbnQ6ICdib3R0b20nXHJcbiAgICAgICAgfSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIGFkZEVsKGJ1dHRvbiwgbWFrZVRleHQoTDEwbi5nZXRWYWx1ZShgaGVhZGVyLSR7bmFtZX1gKSkpO1xyXG4gICAgICAgIHNldEF0dHIoYnV0dG9uLCAnbDEwbi1pZCcsIGBoZWFkZXItJHtuYW1lfWApO1xyXG4gICAgfVxyXG4gICAgYWRkQ2xhc3MoYnV0dG9uLCBidXR0b25DbGFzcyk7XHJcbiAgICBhZGRDbGFzcyhidXR0b24sIGAtdGVzdC0ke25hbWV9YCk7XHJcbiAgICBhZGRDbGFzcyhidXR0b24sIGAtdG9nZ2xlLWNsYXNzLSR7bmFtZX1gKTtcclxuICAgIGlmIChvcHRzLmNsYXp6KSB7XHJcbiAgICAgICAgYWRkQ2xhc3MoYnV0dG9uLCBvcHRzLmNsYXp6KTtcclxuICAgIH1cclxuICAgIGNvbnRhaW5lcnMubmF2aWdhdGlvbi5hcHBlbmRDaGlsZChidXR0b24pO1xyXG5cclxuICAgIGNvbnN0IG9uQ2xpY2tEZWxlZ2F0ZSA9IGZ1bmN0aW9uICh2aWV3Mikge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZXZ0KSB7XHJcbiAgICAgICAgICAgIC8vVGVzdHMucnVuKCk7XHJcbiAgICAgICAgICAgIGNvbnN0IGVsZW1zID0gY29udGFpbmVycy5uYXZpZ2F0aW9uLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoYnV0dG9uQ2xhc3MpO1xyXG4gICAgICAgICAgICBpZiAob3B0cy50b2dnbGUpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IGVscyA9IGdldEVscyhgLXRvZ2dsZS1jbGFzcy0ke25hbWV9YCk7XHJcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVscy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChldnQudGFyZ2V0LmlzRXF1YWxOb2RlKGVsc1tpXSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChoYXNDbGFzcyhlbHNbaV0sICdhY3RpdmUnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNbaV0uY2xpY2soKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIGNvbnN0IGlzQWN0aXZlID0gaGFzQ2xhc3MoZXZ0LnRhcmdldCwgJ2FjdGl2ZScpO1xyXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVsZW1zLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICByZW1vdmVDbGFzcyhlbGVtc1tpXSwgJ2FjdGl2ZScpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghb3B0cy50b2dnbGUgfHwgKG9wdHMudG9nZ2xlICYmICFpc0FjdGl2ZSkpIHtcclxuICAgICAgICAgICAgICAgIGFkZENsYXNzKGV2dC50YXJnZXQsICdhY3RpdmUnKTtcclxuXHJcbiAgICAgICAgICAgICAgICBwYXNzRWxzKGNvbnRhaW5lcnMuY29udGVudCwgZ2V0RWwoJ3dhcmVob3VzZScpKTtcclxuICAgICAgICAgICAgICAgIGNvbnRhaW5lcnMuY29udGVudC5hcHBlbmRDaGlsZCh2aWV3Mi5jb250ZW50KTtcclxuICAgICAgICAgICAgICAgIHJlbW92ZUNsYXNzKGNvbnRhaW5lcnMuY29udGVudCwgJ2hpZGRlbicpO1xyXG4gICAgICAgICAgICAgICAgY29udGFpbmVycy5yb290LmN1cnJlbnRWaWV3ID0gdmlldzI7XHJcbiAgICAgICAgICAgICAgICB2aWV3Mi5yZWZyZXNoKCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICByZW1vdmVDbGFzcyhldnQudGFyZ2V0LCAnYWN0aXZlJyk7XHJcbiAgICAgICAgICAgICAgICBwYXNzRWxzKGNvbnRhaW5lcnMuY29udGVudCwgZ2V0RWwoJ3dhcmVob3VzZScpKTtcclxuICAgICAgICAgICAgICAgIGNvbnRhaW5lcnMucm9vdC5jdXJyZW50VmlldyA9IG51bGw7XHJcbiAgICAgICAgICAgICAgICBhZGRDbGFzcyhjb250YWluZXJzLmNvbnRlbnQsICdoaWRkZW4nKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICB9O1xyXG5cclxuICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIG9uQ2xpY2tEZWxlZ2F0ZSh2aWV3KSk7XHJcbiAgICBpZiAob3B0cy5tYWluUGFnZSkge1xyXG4gICAgICAgIGFkZENsYXNzKGJ1dHRvbiwgJ2FjdGl2ZScpO1xyXG4gICAgICAgIGNvbnRhaW5lcnMuY29udGVudC5hcHBlbmRDaGlsZCh2aWV3LmNvbnRlbnQpO1xyXG4gICAgICAgIGNvbnRhaW5lcnMucm9vdC5jdXJyZW50VmlldyA9IHZpZXc7XHJcbiAgICB9XHJcbn07XHJcblxyXG5VdGlscy5hbGVydCA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XHJcbiAgICB2ZXguZGlhbG9nLmFsZXJ0KG1lc3NhZ2UpO1xyXG59O1xyXG5cclxuVXRpbHMuY29uZmlybSA9IGZ1bmN0aW9uIChtZXNzYWdlLCBvbk9rLCBvbkNhbmNlbCkge1xyXG4gICAgdmV4LmRpYWxvZy5jb25maXJtKHtcclxuICAgICAgICBtZXNzYWdlLFxyXG4gICAgICAgIGNhbGxiYWNrOiAodmFsKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh2YWwpIHtcclxuICAgICAgICAgICAgICAgIGlmIChvbk9rKSBvbk9rKCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob25DYW5jZWwpIG9uQ2FuY2VsKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfSk7XHJcbn07XHJcblxyXG5VdGlscy5yZW1vdmVDaGlsZHJlbiA9IGZ1bmN0aW9uIChteU5vZGUpIHtcclxuICAgIGlmICghbXlOb2RlKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgd2hpbGUgKG15Tm9kZS5maXJzdENoaWxkKSB7XHJcbiAgICAgICAgbXlOb2RlLnJlbW92ZUNoaWxkKG15Tm9kZS5maXJzdENoaWxkKTtcclxuICAgIH1cclxufTtcclxuXHJcblV0aWxzLnByb2Nlc3NFcnJvciA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChlcnIpIHtcclxuICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICAgIFV0aWxzLmhhbmRsZUVycm9yKGVycik7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmIChjYWxsYmFjaykge1xyXG4gICAgICAgICAgICBjb25zdCBhcnIgPSBbXTtcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgICAgIGFyci5wdXNoKGFyZ3VtZW50c1tpXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FsbGJhY2soLi4uYXJyKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59O1xyXG5cclxuVXRpbHMuaGFuZGxlRXJyb3JNc2cgPSBmdW5jdGlvbiAoZXJyKSB7XHJcbiAgICBjb25zdCBjaGVja0Vycm9yVHlwZSA9IFIuY3VycnkoKGVycjIsIG5hbWUpID0+IGVycjIgaW5zdGFuY2VvZiBFcnJvcnNbbmFtZV0gfHwgKGVycjIubmFtZSAmJiBlcnIyLm5hbWUgPT09IG5hbWUpKTtcclxuICAgIGlmIChSLmtleXMoRXJyb3JzKS5zb21lKGNoZWNrRXJyb3JUeXBlKGVycikpKSB7XHJcbiAgICAgICAgcmV0dXJuIHN0ckZvcm1hdChnZXRMMTBuKGVyci5tZXNzYWdlSWQpLCBlcnIucGFyYW1ldGVycyk7XHJcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlcnIgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgcmV0dXJuIGVyci5tZXNzYWdlO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGVycjtcclxufTtcclxuXHJcblV0aWxzLmhhbmRsZUVycm9yID0gZXJyID0+IFV0aWxzLmFsZXJ0KFV0aWxzLmhhbmRsZUVycm9yTXNnKGVycikpO1xyXG5cclxuVXRpbHMuZW5hYmxlRWwgPSBSLmN1cnJ5KChlbCwgY29uZGl0aW9uKSA9PiB7XHJcbiAgICBjb25zdCBrZXkgPSBlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICd0ZXh0YXJlYScgPyAncmVhZG9ubHknIDogJ2Rpc2FibGVkJztcclxuICAgIGlmIChjb25kaXRpb24pIHtcclxuICAgICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoa2V5KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKGtleSwga2V5KTtcclxuICAgIH1cclxufSk7XHJcblxyXG5VdGlscy5lbmFibGUgPSBmdW5jdGlvbiAocm9vdCwgY2xhc3NOYW1lLCBjb25kaXRpb24pIHtcclxuICAgIG5sMmFycmF5KHJvb3QuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShjbGFzc05hbWUpKS5tYXAoVXRpbHMuZW5hYmxlRWwoUi5fXywgY29uZGl0aW9uKSk7XHJcbn07XHJcblxyXG5VdGlscy5jaGFyT3JkQU9iamVjdCA9IENvbW1vblV0aWxzLmNoYXJPcmRBRmFjdG9yeShhID0+IGEuZGlzcGxheU5hbWUudG9Mb3dlckNhc2UoKSk7XHJcblxyXG5VdGlscy5yZWJ1aWxkU2VsZWN0b3IgPSBmdW5jdGlvbiAoc2VsZWN0b3IsIG5hbWVzKSB7XHJcbiAgICBjbGVhckVsKHNlbGVjdG9yKTtcclxuICAgIG5hbWVzLmZvckVhY2goKG5hbWVJbmZvKSA9PiB7XHJcbiAgICAgICAgY29uc3Qgb3B0aW9uID0gbWFrZUVsKCdvcHRpb24nKTtcclxuICAgICAgICBvcHRpb24uYXBwZW5kQ2hpbGQobWFrZVRleHQobmFtZUluZm8uZGlzcGxheU5hbWUpKTtcclxuICAgICAgICBvcHRpb24udmFsdWUgPSBuYW1lSW5mby52YWx1ZTtcclxuICAgICAgICBzZWxlY3Rvci5hcHBlbmRDaGlsZChvcHRpb24pO1xyXG4gICAgfSk7XHJcbn07XHJcblxyXG5VdGlscy5yZWJ1aWxkU2VsZWN0b3JBcnIgPSBmdW5jdGlvbiAoc2VsZWN0b3IsIG5hbWVzKSB7XHJcbiAgICBjbGVhckVsKHNlbGVjdG9yKTtcclxuICAgIG5hbWVzLmZvckVhY2goKG5hbWUpID0+IHtcclxuICAgICAgICBjb25zdCBvcHRpb24gPSBtYWtlRWwoJ29wdGlvbicpO1xyXG4gICAgICAgIG9wdGlvbi5hcHBlbmRDaGlsZChtYWtlVGV4dChuYW1lKSk7XHJcbiAgICAgICAgc2VsZWN0b3IuYXBwZW5kQ2hpbGQob3B0aW9uKTtcclxuICAgIH0pO1xyXG59O1xyXG5cclxuU3RyaW5nLnByb3RvdHlwZS5lbmRzV2l0aCA9IGZ1bmN0aW9uIChzdWZmaXgpIHtcclxuICAgIHJldHVybiB0aGlzLmluZGV4T2Yoc3VmZml4LCB0aGlzLmxlbmd0aCAtIHN1ZmZpeC5sZW5ndGgpICE9PSAtMTtcclxufTtcclxuXHJcbi8vIGZyb20gZGF0ZSBmb3JtYXQgdXRpbHNcclxuLy9Gb3IgY29udmVuaWVuY2UuLi5cclxuRGF0ZS5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24gKG1hc2ssIHV0Yykge1xyXG4gICAgcmV0dXJuIGRhdGVGb3JtYXQodGhpcywgbWFzaywgdXRjKTtcclxufTtcclxuIiwiLypDb3B5cmlnaHQgMjAxNyBUaW1vZmV5IFJlY2hrYWxvdiA8bnRzZGtAeWFuZGV4LnJ1PlxyXG5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcclxueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxyXG5Zb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcclxuXHJcbmh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxyXG5cclxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxyXG5kaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXHJcbldJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxyXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXHJcbiAgICBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS4gKi9cclxuXHJcbid1c2Ugc3RyaWN0JztcclxuXHJcbigoZXhwb3J0cykgPT4ge1xyXG4gICAgY29uc3Qgc3RhdGUgPSB7fTtcclxuICAgIHN0YXRlLnZpZXdzID0ge307XHJcblxyXG4gICAgY29uc3QgYnRuT3B0cyA9IHtcclxuICAgICAgICB0b29sdGlwOiB0cnVlLFxyXG4gICAgICAgIGNsYXNzTmFtZTogJ21haW5OYXZCdXR0b24nXHJcbiAgICB9O1xyXG5cclxuICAgIGV4cG9ydHMub25NYXN0ZXJQYWdlTG9hZCA9ICgpID0+IHtcclxuICAgICAgICBpbml0UGFnZSgpO1xyXG4gICAgICAgIGNvbnN0IExvY2FsREJNUyA9IG1ha2VMb2NhbERCTVModHJ1ZSk7XHJcbiAgICAgICAgaWYgKE1PREUgPT09ICdTdGFuZGFsb25lJykge1xyXG4gICAgICAgICAgICB3aW5kb3cuREJNUyA9IG5ldyBMb2NhbERCTVMoKTtcclxuICAgICAgICAgICAgREJNUy5zZXREYXRhYmFzZShCYXNlRXhhbXBsZS5kYXRhLCAoZXJyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7IFV0aWxzLmhhbmRsZUVycm9yKGVycik7IHJldHVybjsgfVxyXG4gICAgICAgICAgICAgICAgY29uc2lzdGVuY3lDaGVjayhvbkRhdGFiYXNlTG9hZCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoTU9ERSA9PT0gJ05JTVNfU2VydmVyJykge1xyXG4gICAgICAgICAgICBjb25zdCBSZW1vdGVEQk1TID0gbWFrZVJlbW90ZURCTVMoTG9jYWxEQk1TKTtcclxuICAgICAgICAgICAgd2luZG93LkRCTVMgPSBuZXcgUmVtb3RlREJNUygpO1xyXG4gICAgICAgICAgICBjb25zaXN0ZW5jeUNoZWNrKG9uRGF0YWJhc2VMb2FkKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGZ1bmN0aW9uIG9uRGF0YWJhc2VMb2FkKCkge1xyXG4gICAgICAgIC8vICAgICAgICBpbml0VGhlbWUoKTtcclxuXHJcbiAgICAgICAgc3RhdGVJbml0KCk7XHJcblxyXG4gICAgICAgIFV0aWxzLmFkZFZpZXcoc3RhdGUuY29udGFpbmVycywgJ3BlcmZvcm1hbmNlJywgUGVyZm9ybWFuY2UsIHsgbWFpblBhZ2U6IHRydWUgfSk7XHJcbiAgICAgICAgLy8gICAgICAgIFV0aWxzLmFkZFZpZXcoc3RhdGUuY29udGFpbmVycywgJ2luc3RydWN0aW9uJywgSW5zdHJ1Y3Rpb24pO1xyXG5cclxuICAgICAgICBhZGRFbChzdGF0ZS5uYXZpZ2F0aW9uLCBhZGRDbGFzcyhtYWtlRWwoJ2RpdicpLCAnbmF2LXNlcGFyYXRvcicpKTtcclxuXHJcbiAgICAgICAgVXRpbHMuYWRkVmlldyhzdGF0ZS5jb250YWluZXJzLCAnYWJvdXQnLCBBYm91dCk7XHJcblxyXG4gICAgICAgIGFkZEVsKHN0YXRlLm5hdmlnYXRpb24sIG1ha2VCdXR0b24oJ3Rlc3RCdXR0b24nLCAndGVzdCcsIHJ1blRlc3RzLCBidG5PcHRzKSk7XHJcblxyXG4gICAgICAgIGNvbnN0IGJ1dHRvbiA9IG1ha2VCdXR0b24oJ2RhdGFMb2FkQnV0dG9uJywgJ29wZW4tZGF0YWJhc2UnLCBudWxsLCBidG5PcHRzKTtcclxuICAgICAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgRmlsZVV0aWxzLnJlYWRTaW5nbGVGaWxlLCBmYWxzZSk7XHJcblxyXG4gICAgICAgIGNvbnN0IGlucHV0ID0gbWFrZUVsKCdpbnB1dCcpO1xyXG4gICAgICAgIGlucHV0LnR5cGUgPSAnZmlsZSc7XHJcbiAgICAgICAgYWRkQ2xhc3MoaW5wdXQsICdoaWRkZW4nKTtcclxuICAgICAgICBzZXRBdHRyKGlucHV0LCAndGFiaW5kZXgnLCAtMSk7XHJcbiAgICAgICAgYnV0dG9uLmFwcGVuZENoaWxkKGlucHV0KTtcclxuICAgICAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZSkgPT4ge1xyXG4gICAgICAgICAgICBpbnB1dC52YWx1ZSA9ICcnO1xyXG4gICAgICAgICAgICBpbnB1dC5jbGljaygpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGFkZEVsKHN0YXRlLm5hdmlnYXRpb24sIGJ1dHRvbik7XHJcblxyXG4gICAgICAgIC8vICAgICAgICAgICAgICAgIGFkZEVsKHN0YXRlLm5hdmlnYXRpb24sIG1ha2VCdXR0b24oXCJ0aGVtZUJ1dHRvblwiLCBcInRoZW1lXCIsICgpID0+IG5leHRUaGVtZSgpLCBidG5PcHRzKSk7XHJcbiAgICAgICAgYWRkRWwoc3RhdGUubmF2aWdhdGlvbiwgbWFrZUJ1dHRvbignZGF0YVNhdmVCdXR0b24nLCAnc2F2ZS1kYXRhYmFzZScsIEZpbGVVdGlscy5zYXZlRmlsZSwgYnRuT3B0cykpO1xyXG4gICAgICAgIC8vaWYgKE1PREUgPT09ICdTdGFuZGFsb25lJykge1xyXG4gICAgICAgIC8vICBhZGRFbChzdGF0ZS5uYXZpZ2F0aW9uLCBtYWtlQnV0dG9uKCduZXdCYXNlQnV0dG9uJywgJ2NyZWF0ZS1kYXRhYmFzZScsIEZpbGVVdGlscy5tYWtlTmV3QmFzZSwgYnRuT3B0cykpO1xyXG4gICAgICAgIC8vfVxyXG4gICAgICAgIC8vYWRkRWwoc3RhdGUubmF2aWdhdGlvbiwgbWFrZUJ1dHRvbihcIm1haW5IZWxwQnV0dG9uXCIsIFwiZG9jc1wiLCBGaWxlVXRpbHMub3BlbkhlbHAsIGJ0bk9wdHMpKTtcclxuXHJcbiAgICAgICAgYWRkRWwoc3RhdGUubmF2aWdhdGlvbiwgbWFrZUwxMG5CdXR0b24oKSk7XHJcblxyXG4gICAgICAgIC8vICAgICAgICBVdGlscy5hZGRWaWV3KHN0YXRlLmNvbnRhaW5lcnMsICdsb2dWaWV3ZXInLCBMb2dWaWV3ZXIyLCB7IGNsYXp6OiAnbG9nVmlld2VyQnV0dG9uJywgdG9vbHRpcDogdHJ1ZSB9KTtcclxuICAgICAgICAvLyAgICAgICAgYWRkRWwoc3RhdGUubmF2aWdhdGlvbiwgbWFrZUJ1dHRvbigndGVzdEJ1dHRvbicsICd0ZXN0JywgcnVuVGVzdHMsIGJ0bk9wdHMpKTtcclxuXHJcbiAgICAgICAgLy9hZGRFbChzdGF0ZS5uYXZpZ2F0aW9uLCBtYWtlQnV0dG9uKFwicmVmcmVzaEJ1dHRvblwiLCBcInJlZnJlc2hcIiwgKCkgPT4gc3RhdGUuY3VycmVudFZpZXcucmVmcmVzaCgpLCBidG5PcHRzKSk7XHJcblxyXG4gICAgICAgIEZpbGVVdGlscy5pbml0KChlcnIpID0+IHtcclxuICAgICAgICAgICAgaWYgKGVycikgeyBVdGlscy5oYW5kbGVFcnJvcihlcnIpOyByZXR1cm47IH1cclxuICAgICAgICAgICAgY29uc2lzdGVuY3lDaGVjayhzdGF0ZS5jdXJyZW50Vmlldy5yZWZyZXNoKTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgc3RhdGUuY3VycmVudFZpZXcucmVmcmVzaCgpO1xyXG4gICAgICAgIGFkZEJlZm9yZVVubG9hZExpc3RlbmVyKCk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaW5pdFBhZ2UoKSB7XHJcbiAgICAgICAgTDEwbi5sb2NhbGl6ZVN0YXRpYygpO1xyXG4gICAgICAgIEwxMG4ub25MMTBuQ2hhbmdlKCgpID0+IHN0YXRlLmN1cnJlbnRWaWV3LnJlZnJlc2goKSk7XHJcbiAgICAgICAgVUkuaW5pdFNlbGVjdG9yRmlsdGVycygpO1xyXG4gICAgICAgIFVJLmluaXRQYW5lbFRvZ2dsZXJzKCk7XHJcbiAgICAgICAgZnVuY3Rpb24gdXBkYXRlRGlhbG9ncygpIHtcclxuICAgICAgICAgICAgdmV4LmRpYWxvZy5idXR0b25zLllFUy50ZXh0ID0gZ2V0TDEwbignY29tbW9uLW9rJyk7XHJcbiAgICAgICAgICAgIHZleC5kaWFsb2cuYnV0dG9ucy5OTy50ZXh0ID0gZ2V0TDEwbignY29tbW9uLWNhbmNlbCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB1cGRhdGVEaWFsb2dzKCk7XHJcbiAgICAgICAgTDEwbi5vbkwxMG5DaGFuZ2UodXBkYXRlRGlhbG9ncyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gICAgdmFyIGN1clRoZW1lID0gQ29uc3RhbnRzLnRoZW1lTGlzdFsxXTtcclxuICAgIC8vXHJcbiAgICAvLyAgICB2YXIgaW5pdFRoZW1lID0gZnVuY3Rpb24oKSB7XHJcbiAgICAvLyAgICAgICAgaWYoREJNUy5zZXRUaGVtZSl7XHJcbiAgICAvLyAgICAgICAgICAgIERCTVMuZ2V0VGhlbWUoZnVuY3Rpb24oZXJyLCB0aGVtZSl7XHJcbiAgICAvLyAgICAgICAgICAgICAgICBpZihlcnIpIHtjb25zb2xlLmxvZyhlcnIpO31cclxuICAgIC8vICAgICAgICAgICAgICAgIGlmKHRoZW1lICE9PSAnJyl7XHJcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgY3VyVGhlbWUgPSB0aGVtZTtcclxuICAgIC8vICAgICAgICAgICAgICAgIH1cclxuICAgIC8vICAgICAgICAgICAgICAgIGFkZENsYXNzKHF1ZXJ5RWwoJ2JvZHknKSwgY3VyVGhlbWUpO1xyXG4gICAgLy8gICAgICAgICAgICB9KTtcclxuICAgIC8vICAgICAgICB9IGVsc2Uge1xyXG4gICAgLy8gICAgICAgICAgICBhZGRDbGFzcyhxdWVyeUVsKCdib2R5JyksIGN1clRoZW1lKTtcclxuICAgIC8vICAgICAgICB9XHJcbiAgICAvLyAgICB9O1xyXG4gICAgLy9cclxuICAgIC8vICAgIHZhciBuZXh0VGhlbWUgPSBmdW5jdGlvbigpIHtcclxuICAgIC8vICAgICAgICByZW1vdmVDbGFzcyhxdWVyeUVsKCdib2R5JyksIGN1clRoZW1lKTtcclxuICAgIC8vICAgICAgICBjdXJUaGVtZSA9IENvbnN0YW50cy50aGVtZUxpc3RbKFIuaW5kZXhPZihjdXJUaGVtZSwgQ29uc3RhbnRzLnRoZW1lTGlzdCkrMSklQ29uc3RhbnRzLnRoZW1lTGlzdC5sZW5ndGhdO1xyXG4gICAgLy8gICAgICAgIGFkZENsYXNzKHF1ZXJ5RWwoJ2JvZHknKSwgY3VyVGhlbWUpO1xyXG4gICAgLy8gICAgICAgIGlmKERCTVMuc2V0VGhlbWUpe1xyXG4gICAgLy8gICAgICAgICAgICBEQk1TLnNldFRoZW1lKGN1clRoZW1lLCBmdW5jdGlvbihlcnIpe1xyXG4gICAgLy8gICAgICAgICAgICAgICAgaWYoZXJyKSB7Y29uc29sZS5sb2coZXJyKTsgcmV0dXJuO31cclxuICAgIC8vICAgICAgICAgICAgfSk7XHJcbiAgICAvLyAgICAgICAgfVxyXG4gICAgLy8gICAgfTtcclxuXHJcbiAgICBmdW5jdGlvbiBjb25zaXN0ZW5jeUNoZWNrKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgREJNUy5nZXRDb25zaXN0ZW5jeUNoZWNrUmVzdWx0KChlcnIsIGNvbnNpc3RlbmN5RXJyb3JzKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChlcnIpIHsgVXRpbHMuaGFuZGxlRXJyb3IoZXJyKTsgcmV0dXJuOyB9XHJcbiAgICAgICAgICAgIGNvbnNpc3RlbmN5RXJyb3JzLmZvckVhY2goQ29tbW9uVXRpbHMuY29uc29sZUxvZyk7XHJcbiAgICAgICAgICAgIGlmIChjb25zaXN0ZW5jeUVycm9ycy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICBVdGlscy5hbGVydChnZXRMMTBuKCdvdmVydmlldy1jb25zaXN0ZW5jeS1wcm9ibGVtLWRldGVjdGVkJykpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0NvbnNpc3RlbmN5IGNoZWNrIGRpZG5cXCd0IGZpbmQgZXJyb3JzJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBzdGF0ZUluaXQoKSB7XHJcbiAgICAgICAgc3RhdGUubmF2aWdhdGlvbiA9IGdldEVsKCduYXZpZ2F0aW9uJyk7XHJcbiAgICAgICAgc3RhdGUuY29udGFpbmVycyA9IHtcclxuICAgICAgICAgICAgcm9vdDogc3RhdGUsXHJcbiAgICAgICAgICAgIG5hdmlnYXRpb246IHN0YXRlLm5hdmlnYXRpb24sXHJcbiAgICAgICAgICAgIGNvbnRlbnQ6IGdldEVsKCdjb250ZW50QXJlYScpXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBydW5UZXN0cygpIHtcclxuICAgICAgICBEQk1TLmdldENvbnNpc3RlbmN5Q2hlY2tSZXN1bHQoKGVyciwgY29uc2lzdGVuY3lFcnJvcnMpID0+IHtcclxuICAgICAgICAgICAgaWYgKGVycikgeyBVdGlscy5oYW5kbGVFcnJvcihlcnIpOyByZXR1cm47IH1cclxuICAgICAgICAgICAgY29uc2lzdGVuY3lFcnJvcnMuZm9yRWFjaChDb21tb25VdGlscy5jb25zb2xlTG9nKTtcclxuICAgICAgICAgICAgaWYgKGNvbnNpc3RlbmN5RXJyb3JzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICAgIFV0aWxzLmFsZXJ0KGdldEwxMG4oJ292ZXJ2aWV3LWNvbnNpc3RlbmN5LXByb2JsZW0tZGV0ZWN0ZWQnKSk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBVdGlscy5hbGVydChnZXRMMTBuKCdvdmVydmlldy1jb25zaXN0ZW5jeS1pcy1vaycpKTtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdDb25zaXN0ZW5jeSBjaGVjayBkaWRuXFwndCBmaW5kIGVycm9ycycpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gbWFrZUJ1dHRvbihjbGF6eiwgbmFtZSwgY2FsbGJhY2ssIG9wdHMpIHtcclxuICAgICAgICBjb25zdCBidXR0b24gPSBtYWtlRWwoJ2J1dHRvbicpO1xyXG4gICAgICAgIGFkZENsYXNzKGJ1dHRvbiwgY2xhenopO1xyXG4gICAgICAgIGZ1bmN0aW9uIGRlbGVnYXRlKCkge1xyXG4gICAgICAgICAgICAkKGJ1dHRvbikuYXR0cignZGF0YS1vcmlnaW5hbC10aXRsZScsIEwxMG4uZ2V0VmFsdWUoYGhlYWRlci0ke25hbWV9YCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob3B0cy50b29sdGlwKSB7XHJcbiAgICAgICAgICAgIEwxMG4ub25MMTBuQ2hhbmdlKGRlbGVnYXRlKTtcclxuICAgICAgICAgICAgJChidXR0b24pLnRvb2x0aXAoe1xyXG4gICAgICAgICAgICAgICAgdGl0bGU6IEwxMG4uZ2V0VmFsdWUoYGhlYWRlci0ke25hbWV9YCksXHJcbiAgICAgICAgICAgICAgICBwbGFjZW1lbnQ6ICdib3R0b20nXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhZGRDbGFzcyhidXR0b24sICdhY3Rpb24tYnV0dG9uJyk7XHJcbiAgICAgICAgaWYgKG9wdHMuY2xhc3NOYW1lKSB7XHJcbiAgICAgICAgICAgIGFkZENsYXNzKGJ1dHRvbiwgb3B0cy5jbGFzc05hbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY2FsbGJhY2spIHtcclxuICAgICAgICAgICAgbGlzdGVuKGJ1dHRvbiwgJ2NsaWNrJywgY2FsbGJhY2spO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYnV0dG9uO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIG1ha2VMMTBuQnV0dG9uKCkge1xyXG4gICAgICAgIGNvbnN0IGwxMG5CdG4gPSBtYWtlQnV0dG9uKCd0b2dnbGVMMTBuQnV0dG9uJywgJ2wxMG4nLCBMMTBuLnRvZ2dsZUwxMG4sIGJ0bk9wdHMpO1xyXG4gICAgICAgIGZ1bmN0aW9uIHNldEljb24oKSB7XHJcbiAgICAgICAgICAgIGwxMG5CdG4uc3R5bGUuYmFja2dyb3VuZEltYWdlID0gc3RyRm9ybWF0KCd1cmwoXCIuL2ltYWdlcy97MH0uc3ZnXCIpJywgW2dldEwxMG4oJ2hlYWRlci1kaWN0aW9uYXJ5LWljb24nKV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBMMTBuLm9uTDEwbkNoYW5nZShzZXRJY29uKTtcclxuICAgICAgICBzZXRJY29uKCk7XHJcbiAgICAgICAgcmV0dXJuIGwxMG5CdG47XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gYWRkQmVmb3JlVW5sb2FkTGlzdGVuZXIoKSB7XHJcbiAgICAgICAgd2luZG93Lm9uYmVmb3JldW5sb2FkID0gKGV2dCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gZ2V0TDEwbigndXRpbHMtY2xvc2UtcGFnZS13YXJuaW5nJyk7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXZ0ID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgZXZ0ID0gd2luZG93LmV2ZW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChldnQpIHtcclxuICAgICAgICAgICAgICAgIGV2dC5yZXR1cm5WYWx1ZSA9IG1lc3NhZ2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIG1lc3NhZ2U7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgbGlzdGVuKHdpbmRvdywgJ3Bhc3RlJywgZnVuY3Rpb24gKGV2dCkge1xyXG4gICAgICAgIHRyeXtcclxuICAgICAgICAgICAgSlNPTi5wYXJzZShldnQuY2xpcGJvYXJkRGF0YS5nZXREYXRhKFwidGV4dFwiKSlcclxuICAgICAgICB9IGNhdGNoKGUpe1xyXG4gICAgICAgICAgICBVdGlscy5hbGVydCgnRXJyb3Igb24gcGFyc2luZyBiYXNlICcgKyBlKTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBEQk1TLnNldERhdGFiYXNlKEpTT04ucGFyc2UoZXZ0LmNsaXBib2FyZERhdGEuZ2V0RGF0YShcInRleHRcIikpLCAoZXJyKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChlcnIpIHsgVXRpbHMuaGFuZGxlRXJyb3IoZXJyKTsgcmV0dXJuOyB9XHJcbiAgICAgICAgICAgIGNvbnNpc3RlbmN5Q2hlY2soc3RhdGUuY3VycmVudFZpZXcucmVmcmVzaCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9KTtcclxufSkodGhpcy5QYWdlTWFuYWdlciA9IHt9KTtcclxuIl0sInNvdXJjZVJvb3QiOiIvc291cmNlLyJ9
